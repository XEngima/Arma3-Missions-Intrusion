/*
 * Name:	AiSquadBrain
 * Date:	2019-05-17
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Models the brain of the squad leader that takes all decisions of the team.
 */

using Intrusion.Common;
using Intrusion.Server;
using Sqx.Collections;

namespace Intrusion.Ai
{
	public class AiSquadBrain
	{
		private fields ["_mKnowledge" as IKnowledge, "_mWorld" as IWorld, "_mActionPerformer" as IActionPerformer, "_mRandomGenerator" as IRandomGenerator,
						"_mMapMarkerInfo" as MapMarkerInfo, "_mMarkerHandler" as IMarkerHandler, "_mCurrentAction" as IAction];
	
		// Creates a AiSquadBrain object.
		public constructor
		(
			"_group" as Group, 
			"_world" as IWorld, 
			"_actionPerformer" as IActionPerformer, 
			"_randomGenerator" as IRandomGenerator,
			"_mapMarkerInfo" as MapMarkerInfo,
			"_markerHandler" as IMarkerHandler,
			["_knowledge" as IKnowledge, classNull])
		{
			_mWorld = _world;
			_mActionPerformer = _actionPerformer;
			_mRandomGenerator = _randomGenerator;
			_mMapMarkerInfo = _mapMarkerInfo;
			_mMarkerHandler = _markerHandler;
			_mCurrentAction = classNull;
			
			if (!isNull _knowledge) then {
				_mKnowledge = _knowledge;
				
				_mKnowledge.Group = _group;
				_mKnowledge.Members = units _group;
			}
			else {
				_mKnowledge = [_group] new Knowledge;
			};
		};
		
		// Creates a new order on own initiative.
		private method CreateOrderOnOwnInitiative()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection, "_location" as ResourceLocation, "_locations" as Array /* of ResourceLocation */, "_valuedLocations" as Array /* of ValuedObject */];
			private ["_count" as Scalar, "_index" as Scalar];
			
			// Find the three enemy (or neutral) resource locations closest to the base and select a random one of them.

			_resourceLocationCollection = call _mWorld.GetResourceLocationCollection;
			
			_locations = call _resourceLocationCollection.GetResourceLocations;
			_count = 0;
			_valuedLocations = [];
			
			{
				_location = _x;
				
				if (_location.Side != side _mKnowledge.Group) then {
					_valuedLocations pushBack [_location, ([_location.MarkerName] call _mMarkerHandler.GetMarkerPos) distance ([_mMapMarkerInfo.BaseMarkerName] call _mMarkerHandler.GetMarkerPos)] new ValuedObject;
					_count = _count + 1;
				};
			} foreach _locations as ResourceLocation;
			
			_valuedLocations = [_valuedLocations] call Sorter.QSort;
			
			if (_count > 3) then {
				_count = 3;
			};
			
			if (_count > 0) then {
				_index = floor ([_count] call _mRandomGenerator.GetNumber);
				_location = ((_valuedLocations select _index) as ValuedObject).Object as ResourceLocation;
				_mKnowledge.Order = [_mKnowledge.Group, OrderType.Attack, [_location.MarkerName] call _mMarkerHandler.GetMarkerPos, _location] new Order;
			};
		};
		
		private method MakeDecision()
		{
			private ["_locationCollection" as ResourceLocationCollection, "_locations" as Array /* of ResourceLocation */, "_pos" as Array];
			private ["_locationMarkerName" as String];
			
			scopeName "main";
			
			
			// If inside the perimiters of a resource location that should be captured, capture it!
			
			_locationCollection = call _mWorld.GetResourceLocationCollection;
			_locations = call _locationCollection.GetResourceLocations;
			
			{
				if ([_mKnowledge.Group, _x] call _mWorld.CheckSquadPresenceAtResourceLocation) then {
					_mKnowledge.State = AiSquadState.Capturing;
					_pos = [_x.MarkerName] call _mMarkerHandler.GetMarkerPos;
					_mCurrentAction = [_pos, _x.MarkerName] new CaptureAction;
					[_mCurrentAction as CaptureAction] call _mActionPerformer.DoCapture;
					breakOut "main";
				};
			} foreach _locations as ResourceLocation;
			
			
			// Move towards order's target!
			
			_mKnowledge.State = AiSquadState.Moving;
			_locationMarkerName = "";
			
			if (!isNull _mKnowledge.Order.ResourceLocation) then {
				_locationMarkerName = _mKnowledge.Order.ResourceLocation.MarkerName;
			};
			
			_mCurrentAction = [_mKnowledge.Order.TargetPosition, _locationMarkerName] new MoveAction;
			[_mCurrentAction as MoveAction] call _mActionPerformer.DoMove;
			breakOut "main";
			
			// ...
		};
		
		#region Completion Checks
		
		// Gets whether the group has completed a move action.
		private method Boolean HasCompletedMove()
		{
			private ["_moveAction" as MoveAction, "_hasCompleted" as Boolean, "_leaderPos" as Array];
			private ["_location" as ResourceLocation, "_locationCollection" as ResourceLocationCollection];
			
			_hasCompleted = false;
			
			//if ((_mKnowledge.CurrentAction) is MoveAction) then // TODO SQX: Generates error that 'required variable before is'.
			
			if (_mCurrentAction is MoveAction) then
			{
				// Move is completed if the squad is at the destination position
				_leaderPos = [_mKnowledge.Group] call _mWorld.GetLeaderPos;
				_moveAction = _mCurrentAction as MoveAction;				
				_hasCompleted = _leaderPos distance _moveAction.Position < 20;
				
				// Move is completed if the order movement is related to a resource location that is already ours
				if (!_hasCompleted) then
				{
					_locationCollection = call _mWorld.GetResourceLocationCollection;
					_location = [_moveAction.LocationMarkerName] call _locationCollection.GetResourceLocationByMarkerName;
					
					if (_location.Side == side _mKnowledge.Group) then
					{
						_hasCompleted = true;
					};
				};
			};
			
			_hasCompleted
		};
		
		// Gets whether the group has completed a capture action, i.e. it is no longer present at a resource location with enemy side.
		private method Boolean HasCompletedCapture()
		{
			private ["_captureAction" as CaptureAction, "_hasCompleted" as Boolean];
			private ["_location" as ResourceLocation, "_locationCollection" as ResourceLocationCollection];
			
			_hasCompleted = false;
			
			if (_mCurrentAction is CaptureAction) then
			{
				_captureAction = _mCurrentAction as CaptureAction;
				
				_locationCollection = call _mWorld.GetResourceLocationCollection;
				_location = [_captureAction.LocationMarkerName] call _locationCollection.GetResourceLocationByMarkerName;
				
				if (_location.Side == side _mKnowledge.Group) then {
					_hasCompleted = true;
				};
				
				
				if (!_hasCompleted) then {
					if (!([_mKnowledge.Group, _location] call _mWorld.CheckSquadPresenceAtResourceLocation)) then {
						_hasCompleted = true;
					};
				};
			};
			
			_hasCompleted
		};
		
		// Gets whether the last action has completed or not.
		// Returns (Boolean): true if the last action has completed, otherwise false.
		public method Boolean GetHasCompleted()
		{
			private ["_hasCompleted" as Boolean];
			
			if (_mCurrentAction is MoveAction) then {
				_hasCompleted = call _self.HasCompletedMove;
			};
			
			if (_mCurrentAction is CaptureAction) then {
				_hasCompleted = call _self.HasCompletedCapture;
			};
			
			_hasCompleted
		};
		
		#endregion
		
		// Gives the AI brain an opportunity to make a new decision.
		public method Act()
		{
			// If there is no order, create one on own initiative so the group has something to do.
			
			if (isNull _mKnowledge.Order) then {
				call _self.CreateOrderOnOwnInitiative;
			};
			
			// If the squad is not doing anything, make a new decision.
		
			if (_mKnowledge.State == AiSquadState.Idle) then {
				call _self.MakeDecision;
			}
			else
			{
				// If the squad is doing something, check if it has completed doing it.
				
				if (call _self.GetHasCompleted) then {
					_mKnowledge.State = AiSquadState.Idle;
				};
			};
			
		};
	};
};
