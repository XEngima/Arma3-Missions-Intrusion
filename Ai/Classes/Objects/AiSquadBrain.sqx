/*
 * Name:	AiSquadBrain
 * Date:	2019-05-17
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Models the brain of the squad leader that takes all decisions of the team.
 */

using Intrusion.Common;
using Intrusion.Server;
using Sqx.Collections;

namespace Intrusion.Ai
{
	public class AiSquadBrain
	{
		private fields ["_mKnowledge" as IKnowledge, "_mWorld" as IWorld, "_mActionPerformer" as IActionPerformer, "_mRandomGenerator" as IRandomGenerator,
						"_mMarkerHandler" as IMarkerHandler, "_mActionTimeoutConfig" as IActionTimeoutConfig, "_mTime" as IMissionTime,
						"_mActionServiceFactory" as IActionServiceFactory, "_mAiWeaponInfo" as AiWeaponInfo, "_mInventedTechnologiesCollection" as InventedTechnologiesCollection];
		
		#region Initialization

		// Creates a AiSquadBrain object.
		public constructor
		(
			"_group" as Group,
			"_world" as IWorld, 
			"_actionPerformer" as IActionPerformer, 
			"_randomGenerator" as IRandomGenerator,
			"_markerHandler" as IMarkerHandler,
			"_actionTimeoutConfig" as IActionTimeoutConfig,
			"_time" as IMissionTime,
			"_baseMarkerInfo" as MapMarkerInfo,
			"_actionServiceFactory" as IActionServiceFactory,
			"_aiWeaponsConfig" as IAiWeaponsConfig,
			"_inventedTechnologiesCollection" as InventedTechnologiesCollection,
			["_knowledge" as IKnowledge, classNull])
		{
			private ["_members" as Array];
		
			_self.Group = _group;
			_mWorld = _world;
			_mActionPerformer = _actionPerformer;
			_mRandomGenerator = _randomGenerator;
			_mMarkerHandler = _markerHandler;
			_mActionTimeoutConfig = _actionTimeoutConfig;
			_mTime = _time;
			_mActionServiceFactory = _actionServiceFactory;
			_mAiWeaponInfo = [side _group] call _aiWeaponsConfig.GetWeaponInfo;
			_mInventedTechnologiesCollection = _inventedTechnologiesCollection;
			
			if (!isNull _knowledge) then {
				_mKnowledge = _knowledge;
				
				_mKnowledge.Group = _group;
			}
			else {
				_members = [];
				
				{
					_members pushBack [_x] new UnitContainer;
				} foreach units _group;
				
				_mKnowledge = [_group, _members] new Knowledge;
			};
			
			_mKnowledge.BaseMarkerInfo = _baseMarkerInfo;
		};
		
		public method Scalar GetMemberCount()
		{
			count _mKnowledge.Members
		};
		
		public property Group Group { get; private set; };
		
		#endregion
		
		#region Decision Making
		
		// Creates a new order on own initiative.
		private method CreateOrderOnOwnInitiative()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection, "_location" as ResourceLocation, "_locations" as Array /* of ResourceLocation */, "_valuedLocations" as Array /* of ValuedObject */];
			private ["_count" as Scalar, "_index" as Scalar, "_distanceFromBase" as Scalar];
			
			// Find the three enemy (or neutral) resource locations closest to the base and select a random one of them.

			_resourceLocationCollection = call _mWorld.GetResourceLocationCollection;
			
			if (!isNull _resourceLocationCollection) then
			{
				_locations = call _resourceLocationCollection.GetResourceLocations;
				_count = 0;
				_valuedLocations = [];
				
				{
					_location = _x;
					
					if (_location.Side != side _mKnowledge.Group) then {
						_distanceFromBase = ([_location.MarkerName] call _mMarkerHandler.GetMarkerPos) distance ([_mKnowledge.BaseMarkerInfo.BaseMarkerName] call _mMarkerHandler.GetMarkerPos);
						_valuedLocations pushBack [_location, _distanceFromBase] new ValuedObject;
						_count = _count + 1;
					};
				} foreach _locations as ResourceLocation;
				
				_valuedLocations = [_valuedLocations] call Sorter.QSort;
				
				if (_count > 3) then {
					_count = 3;
				};
				
				if (_count > 0) then {
					_index = floor ([_count] call _mRandomGenerator.GetNumber);
					_location = ((_valuedLocations select _index) as ValuedObject).Object as ResourceLocation;
					
					// _location is here a copied object, since it has been sorted. But we want it to be a reference.
					_location = [_location.MarkerName] call _resourceLocationCollection.GetResourceLocationByMarkerName;
					
					// Create the order
					_mKnowledge.Order = [_mKnowledge.Group, OrderType.Attack, [_location.MarkerName] call _mMarkerHandler.GetMarkerPos, _location] new Order;
				
					["AiSquadBrain.CreateOrderOnOwnInitiative"] call LogHandler.Debug;
					["_this: " + str _this] call LogHandler.Debug;
					["_locations: " + str _locations] call LogHandler.Debug;
					["_count: " + str _count] call LogHandler.Debug;
					["_valuedLocations: " + str _valuedLocations] call LogHandler.Debug;
					["_index: " + str _index] call LogHandler.Debug;
					["_mKnowledge.Order: " + str _mKnowledge.Order] call LogHandler.Debug;
				};
			};
		};
		
		private method MakeDecision()
		{
			private ["_locationCollection" as ResourceLocationCollection, "_locations" as Array /* of ResourceLocation */, "_pos" as Array];
			private ["_locationMarkerName" as String, "_aiVehicle" as VehicleContainer, "_leaderPos" as Array, "_side" as Side, "_time" as Scalar];
			private ["_action" as IAction, "_squadInVehicle" as Boolean, "_actionService" as IActionService, "_enemyContainer" as IUnitContainer];
			
        	["MakeDecision()"] call LogHandler.Debug;
			scopeName "main";
			
			_leaderPos = [_mKnowledge.Group] call _mWorld.GetLeaderPos;
			_side = side _mKnowledge.Group;
			_time = call _mTime.GetMissionTime;
			_squadInVehicle = [_mKnowledge.Group] call _mWorld.CheckSquadMounted;
			_action = _mKnowledge.CurrentAction;
			
        	["_squadInVehicle: " + str _squadInVehicle] call LogHandler.Debug;
        	["_action: " + str _action] call LogHandler.Debug;
        	["_leaderPos: " + str _leaderPos] call LogHandler.Debug;
			
			
			// If target resource location is already captured, and the order was on own initiative, request a new order!

        	["_mKnowledge.OrderIsGivenByBrigadeLeader: " + str (_mKnowledge.OrderIsGivenByBrigadeLeader)] call LogHandler.Debug;
        	["isNull _mKnowledge.Order.ResourceLocation: " + str (isNull _mKnowledge.Order.ResourceLocation)] call LogHandler.Debug;


			if (!_mKnowledge.OrderIsGivenByBrigadeLeader && !(isNull _mKnowledge.Order.ResourceLocation)) then
			{
	        	["_mKnowledge.Order.ResourceLocation.Side: " + str (_mKnowledge.Order.ResourceLocation.Side)] call LogHandler.Debug;
	        	["side _mKnowledge.Group: " + str (side _mKnowledge.Group)] call LogHandler.Debug;
	        	
				if (_mKnowledge.Order.ResourceLocation.Side == side _mKnowledge.Group) then
				{
					call _self.CreateOrderOnOwnInitiative;
					player sideChat ("New order: " + _mKnowledge.Order.ResourceLocation.MarkerName);
		        	["Order created: " + str _mKnowledge.Order] call LogHandler.Debug;
					breakOut "main";
				};
			};
			
			// If squad is not mounted and enemies spotted near, engage
			
			_enemyContainer = [_mKnowledge.Group] call _mWorld.GetClosestDetectedEnemy;
			
        	["_unitContainer: " + str _enemyContainer] call LogHandler.Debug;
			
			if (!_squadInVehicle && !isNull _enemyContainer && { _leaderPos distance (call _enemyContainer.GetPosition) < 100 }) then
			{
				_action = [_time + 20, (call _enemyContainer.GetPosition)] new EngageAction;
				[AiSquadState.Engaging, _action] call _self.SetState;
	        	["Engage action created: " + str _action] call LogHandler.Debug;
				breakOut "main";
			};
			

			// If squad is mounted and enemies spotted near, disembark
			
			if (_squadInVehicle && !isNull _enemyContainer && { _leaderPos distance (call _enemyContainer.GetPosition) < 100 }) then
			{
				_aiVehicle = [_mKnowledge.Group] call _mWorld.GetMountedVehicle;
				_actionService = [_mTime, _time + 20, _mWorld, _mActionPerformer, _mKnowledge.Group, _aiVehicle] call _mActionServiceFactory.CreateDisembarkService;
				call _actionService.RunAsync;
				_action = [_time + 20, _aiVehicle, _actionService as DisembarkActionService] new DisembarkAction;
				[AiSquadState.Disembarking, _action] call _self.SetState;
	        	["Disembark action #2 created: " + str _action] call LogHandler.Debug;
				breakOut "main";
			};
			

			// If squad is mounted and near a destination (<150m), set disembark.
			
			if (_squadInVehicle) then
			{
				if (_leaderPos distance _mKnowledge.Order.TargetPosition <= 150) then
				{
					_aiVehicle = [_mKnowledge.Group] call _mWorld.GetMountedVehicle;
					_actionService = [_mTime, _time + 20, _mWorld, _mActionPerformer, _mKnowledge.Group, _aiVehicle] call _mActionServiceFactory.CreateDisembarkService;
					call _actionService.RunAsync;
					_action = [_time + 20, _aiVehicle, _actionService as DisembarkActionService] new DisembarkAction;
					[AiSquadState.Disembarking, _action] call _self.SetState;
		        	["Disembark action created: " + str _action] call LogHandler.Debug;
					breakOut "main";
				};
			};
			

			// If inside the perimiters of a resource location that should be captured, capture it!

			_locationCollection = call _mWorld.GetResourceLocationCollection;
			_locations = call _locationCollection.GetResourceLocations;
			
			{
				if (_x.Side != _side && { [_mKnowledge.Group, _x] call _mWorld.CheckSquadPresenceAtResourceLocation }) then
				{
					_pos = [_x.MarkerName] call _mMarkerHandler.GetMarkerPos;
					_action = [_time + _mActionTimeoutConfig.CaptureActionTimeout, _pos, _x.MarkerName] new CaptureAction;
					[AiSquadState.Capturing, _action] call _self.SetState;
					[_mKnowledge.CurrentAction as CaptureAction] call _mActionPerformer.DoCapture;
		        	["Capture action created: " + str _action] call LogHandler.Debug;
					breakOut "main";
				};
			} foreach _locations as ResourceLocation;

			
			// If distance to ordered position is less than far, move to it (by foot).
			
			if (_leaderPos distance _mKnowledge.Order.TargetPosition < 150) then
			{
				_action = [_time + _mActionTimeoutConfig.MoveActionTimeout, _mKnowledge.Order.TargetPosition, _mKnowledge.Order.ResourceLocation.MarkerName] new MoveAction;
				[AiSquadState.Moving, _action] call _self.SetState;
				[_action as MoveAction] call _mActionPerformer.DoMove;
	        	["Move action created #1: " + str _action] call LogHandler.Debug;
				breakOut "main";
			};


			// If squad is on foot and standing right beside an empty vehicle, then mount.
			
			_aiVehicle = classNull;
			
			if (!_squadInVehicle) then
			{
				_aiVehicle = [_side, _leaderPos, count _mKnowledge.Members] call _mWorld.GetClosestEmptyFreeVehicle;
				
				if (!isNull _aiVehicle && { _aiVehicle.Position distance _leaderPos <= 20 }) then
				{
					_action = [_time + 20, _aiVehicle] new MountAction;
					[AiSquadState.MountingVehicle, _action] call _self.SetState;
					[_action as MountAction] call _mActionPerformer.DoMount;
		        	["Mount action created: " + str _action] call LogHandler.Debug;
					breakOut "main";
				};
			};

			
			// If squad is on foot and an empty vehicle is nearby, move to it.
			// Nearby means one fourth of the distance to the aimed location
			
			if (!_squadInVehicle && { !isNull _aiVehicle }) then
			{
				private _distanceToVehicle = _aiVehicle.Position distance _leaderPos as Scalar;
				private _distanceToTargetPos = _mKnowledge.Order.TargetPosition distance _leaderPos as Scalar;
				
	        	["_distanceToVehicle: " + str _distanceToVehicle] call LogHandler.Debug;
	        	["_distanceToTargetPos: " + str _distanceToTargetPos] call LogHandler.Debug;
		        	
				if (!isNull _aiVehicle && { (_distanceToVehicle / _distanceToTargetPos) < 0.25 }) then {
					_action = [_time + _mActionTimeoutConfig.MoveActionTimeout, _aiVehicle.Position, _mKnowledge.Order.ResourceLocation.MarkerName] new MoveAction;
					[AiSquadState.Moving, _action] call _self.SetState;
					[_action as MoveAction] call _mActionPerformer.DoMove;
		        	["Move action created #2: " + str _action] call LogHandler.Debug;
					breakOut "main";
				};
			};
			
			
			// If not already there, move towards order's target!
			
			if (_leaderPos distance _mKnowledge.Order.TargetPosition > 25) then
			{
				_locationMarkerName = "";
				
				if (!isNull _mKnowledge.Order.ResourceLocation) then {
					_locationMarkerName = _mKnowledge.Order.ResourceLocation.MarkerName;
				};
				
				_action = [_time + _mActionTimeoutConfig.MoveActionTimeout, _mKnowledge.Order.TargetPosition, _locationMarkerName] new MoveAction;
				[AiSquadState.Moving, _action] call _self.SetState;
				[_mKnowledge.CurrentAction as MoveAction] call _mActionPerformer.DoMove;
	        	["Move action created #3: " + str _action] call LogHandler.Debug;
				breakOut "main";
			};
		};
		
		private method SetState("_state" as AiSquadState, "_action" as IAction) 
		{
			_mKnowledge.State = _state;
			
			if (_state == AiSquadState.Idle) then {
				_mKnowledge.CurrentAction = classNull;
			}
			else {
				_mKnowledge.CurrentAction = _action;
			};
			
			player sideChat "Setting status for " + str _mKnowledge.Group + " (" + str (count units _mKnowledge.Group) + "): " + ([_state] call AiSquadStateMeta.ToString);
		};
		
		#endregion
		
		#region Completion and Timeout
		
		// Gets whether the group has completed a move action.
		private method Boolean HasCompletedMove()
		{
			private ["_moveAction" as MoveAction, "_leaderPos" as Array, "_squadInVehicle" as Boolean, "_unitContainer" as IUnitContainer];
			private ["_location" as ResourceLocation, "_locationCollection" as ResourceLocationCollection, "_currentAction" as IAction];
			
			scopeName "main";

			//if ((_mKnowledge.CurrentAction) is MoveAction) then // TODO SQX: Generates error that 'required variable before is'.
			_currentAction = _mKnowledge.CurrentAction; // TODO SQX: This is the temporary workaround...
			
			if (_currentAction is MoveAction) then
			{
				_leaderPos = [_mKnowledge.Group] call _mWorld.GetLeaderPos;
				_squadInVehicle = [_mKnowledge.Group] call _mWorld.CheckSquadMounted;
				_moveAction = _currentAction as MoveAction;
				
				_unitContainer = [_mKnowledge.Group] call _mWorld.GetClosestDetectedEnemy;
			
				// Move is completed if the squad is mounted and can see nearby enemies
				if (_squadInVehicle &&  !isNull _unitContainer && { _leaderPos distance (call _unitContainer.GetPosition) < 100 }) then {
		        	["Completed move #0"] call LogHandler.Debug;
					player sideChat "Completed #0";
					true breakOut "main";
				};
				
				// Move is completed if the squad is mounted and near the destination
				if (_squadInVehicle && _leaderPos distance _moveAction.Position <= 150) then {
		        	["Completed move #1"] call LogHandler.Debug;
					player sideChat "Completed #1";
					true breakOut "main";
				};
				
				// Move is completed if the squad is at the destination position
				
				if (_leaderPos distance _moveAction.Position < 20) then {
					player sideChat "Completed #2";
		        	["Completed move #2"] call LogHandler.Debug;
					true breakOut "main";
				};
				
				// Move is completed if the order movement is related to a resource location that is already ours
				_locationCollection = call _mWorld.GetResourceLocationCollection;
				_location = [_moveAction.LocationMarkerName] call _locationCollection.GetResourceLocationByMarkerName;
				
				if (_location.Side == side _mKnowledge.Group) then
				{
					player sideChat "Completed #3";
		        	["Completed move #3"] call LogHandler.Debug;
					true breakOut "main";
				};
			};
			
			false
		};
		
		// Gets whether the group has completed a capture action, i.e. it is no longer present at a resource location with enemy side.
		private method Boolean HasCompletedCapture()
		{
			private ["_captureAction" as CaptureAction, "_hasCompleted" as Boolean];
			private ["_location" as ResourceLocation, "_locationCollection" as ResourceLocationCollection, "_currentAction" as IAction];
			
			_hasCompleted = false;
			_currentAction = _mKnowledge.CurrentAction;
			
			if (_currentAction is CaptureAction) then
			{
				_captureAction = _currentAction as CaptureAction;
				
				_locationCollection = call _mWorld.GetResourceLocationCollection;
				_location = [_captureAction.LocationMarkerName] call _locationCollection.GetResourceLocationByMarkerName;
				
				if (_location.Side == side _mKnowledge.Group) then {
					_hasCompleted = true;
				};
				
				
				if (!_hasCompleted) then {
					if (!([_mKnowledge.Group, _location] call _mWorld.CheckSquadPresenceAtResourceLocation)) then {
						_hasCompleted = true;
					};
				};
			};
			
			_hasCompleted
		};
		
		// Gets whether the group has completed a mount vehicle action, i.e. all members are in the same vehicle.
		private method Boolean HasCompletedMount()
		{
			private ["_currentAction" as IAction];
		
			private _hasCompleted = false;
			_currentAction = _mKnowledge.CurrentAction;
		
			if (_currentAction is MountAction) then
			{
				_hasCompleted = [_mKnowledge.Group] call _mWorld.CheckSquadMounted;
			};
			
			_hasCompleted
		};
		
		// Gets whether the last action has completed or not.
		// Returns (Boolean): true if the last action has completed, otherwise false.
		public method Boolean GetHasCompleted()
		{
			private ["_hasCompleted" as Boolean, "_currentAction" as IAction, "_actionService" as IActionService];

			scopeName "main";
			
			_hasCompleted = false;
			
			// If the action has a service, check if that service has completed or not.
			
			if (!isNull _mKnowledge.CurrentAction) then {
				_actionService = _mKnowledge.CurrentAction.Service;
				
				if (!isNull _actionService) then {
					if (!_actionService.IsRunning && _actionService.Success) then {
						true breakOut "main";
					};
				};
			};
			
			_currentAction = _mKnowledge.CurrentAction;

			if (_currentAction is MoveAction) then {
				_hasCompleted = call _self.HasCompletedMove;
			};
			
			if (_currentAction is CaptureAction) then {
				_hasCompleted = call _self.HasCompletedCapture;
			};
			
			if (_currentAction is MountAction) then {
				_hasCompleted = call _self.HasCompletedMount;
			};
			
			_hasCompleted
		};
		
		// Tracks the leader's movement, and stationary for so long time that squad status should be set to idle.
		// Returns (Boolean): true if an action timeout has occurred, otherwise false.
		private method Boolean CheckActionTimeout()
		{
			private ["_leaderPos" as Array, "_action" as IAction, "_actionService" as IActionService];
			
			scopeName "main";
			
			// If the action has a service, check if that service has timed out or not.
			
			if (!isNull _mKnowledge.CurrentAction) then {
				_actionService = _mKnowledge.CurrentAction.Service;
	        	["_actionService: " + str _actionService] call LogHandler.Debug;
				
				if (!isNull _actionService) then {
					if (!_actionService.IsRunning && !_actionService.Success) then {
			        	["Timeout occurred #1"] call LogHandler.Debug;
						true breakOut "main";
					};
				};
			};
			
			// If leader has moved since last time, update position and time
			
			_leaderPos = [_mKnowledge.Group] call _mWorld.GetLeaderPos;
			
			if (!(_leaderPos isEqualTo _mKnowledge.LeaderPos)) then {
				_mKnowledge.LeaderPos = _leaderPos;
				_mKnowledge.LeaderPosTime = call _mTime.GetMissionTime;
			}
			else
			{
				// If leader has not moved since last time, check if current action should time out
				if ((call _mTime.GetMissionTime) > _mKnowledge.LeaderPosTime + _mActionTimeoutConfig.LeaderStationaryTimeout) then {
		        	["Timeout occurred #2"] call LogHandler.Debug;
					_mKnowledge.LeaderPosTime = call _mTime.GetMissionTime;
					true breakOut "main";
				};
			};
			
			// Check if the current action has timed out
			_action = _mKnowledge.CurrentAction;
			if (!isNull _action && { (call _mTime.GetMissionTime) >= _action.TimeoutTime }) then {
	        	["Timeout occurred #3"] call LogHandler.Debug;
				true breakOut "main";
			};
			
			false
		};
		
		#endregion
		
		#region Public Methods
		
		public method GiveOrder("_order" as Order)
		{
			_mKnowledge.Order = _order;
			_mKnowledge.OrderIsGivenByBrigadeLeader = true;
		};
		
		private method Boolean GetAllMembersAreDead()
		{
			scopeName "main";
			
			{
				if (call _x.GetIsAlive) then {
					false breakOut "main";
				};
			} foreach _mKnowledge.Members as IUnitContainer;
			
			true
		};
		
		private method RespawnToBase()
		{
			private ["_newMembers" as Array /* of IUnitContainer */, "_atLaunchersInvented" as Boolean, "_aaLaunchersInvented" as Boolean];
			
			_newMembers = [_mKnowledge.Group, _mKnowledge.Members, _mKnowledge.BaseMarkerInfo.BaseMarkerName] call _mActionPerformer.RespawnAiSquad;
			_mKnowledge.Members = _newMembers;
			
			_atLaunchersInvented = [side _mKnowledge.Group, Technology.Ordnance] call _mInventedTechnologiesCollection.SideTechnologyIsInvented;
			_aaLaunchersInvented = [side _mKnowledge.Group, Technology.AntiAir] call _mInventedTechnologiesCollection.SideTechnologyIsInvented;

			{
				if (_atLaunchersInvented && ([1] call _mRandomGenerator.GetNumber) < _mAiWeaponInfo.ProbabilityAiTakesAtLauncher) then {
					[_x, _mAiWeaponInfo.AtLauncherClassName, _mAiWeaponInfo.AtLauncherAmmoClassName] call _mActionPerformer.EquipMemberWithLauncher;
				}
				else {
					if (_aaLaunchersInvented && ([1] call _mRandomGenerator.GetNumber) > _mAiWeaponInfo.ProbabilityAiTakesAaLauncher) then {
						[_x, _mAiWeaponInfo.AaLauncherClassName, _mAiWeaponInfo.AaLauncherAmmoClassName] call _mActionPerformer.EquipMemberWithLauncher;
					};
				};
			} foreach _newMembers as IUnitContainer;
		};
		
		// Gives the AI brain an opportunity to make a new decision.
		public method Act()
		{
			scopeName "main";
			
			// If all members are dead, respawn.
			if (call _self.GetAllMembersAreDead) then {
				call _self.RespawnToBase;
				[AiSquadState.Idle, classNull] call _self.SetState;
				breakOut "main";
			};
		
			// If there is no order, create one on own initiative so the squad always has an order.
			if (isNull _mKnowledge.Order) then {
				call _self.CreateOrderOnOwnInitiative;
			};
			
			// If the squad is not doing anything, make a new decision.
		
			if (_mKnowledge.State == AiSquadState.Idle) then {
				call _self.MakeDecision;
			}
			else
			{
				// If there has been a timeout or if the squad is complete doing something, set to idle.
				
				if (call _self.CheckActionTimeout || { call _self.GetHasCompleted }) then {
					[AiSquadState.Idle, classNull] call _self.SetState;
				};
			};
		};
		
		#endregion
	};
};
