/*
 * Name:	ProductionQueue
 * Date:	2017-11-19
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * A queue for the groups on the side to get needed materiels as soon as the side can afford it.
 */

using Sqx.Collections;

namespace Intrusion.Server
{
	public class OrderQueue
	{
		private fields ["_mGroups" as Array /* of Group */, "_mCurrentIndex" as Scalar];
		
		// Creates a ProductionQueue object.
		public constructor {
			_mGroups = [];
			_mCurrentIndex = -1;
			_self.CurrentOrder = grpNull;
		};
		
		// Gets the group currently being built for.
		public property Group CurrentOrder { get; private set; };
		
		// Adds a group to the queue if it is not already in it.
		// _group (Group): The group to add.
		public method PutOrder {
			params ["_group" as Group];
			
			_mGroups pushBack _group;
			
			if (_mCurrentIndex < 0) then {
				_mCurrentIndex = 0;
				_self.CurrentOrder = _group;
			};
		};
		
		private method RemoveAtIndex {
			params ["_index" as Scalar];
			_mGroups = [_mGroups, _index] call ArrayHandler.RemoveItemAtIndex;
		};
		
		// Removes the current order and moves the queue pointer to the next group in the queue.
		// Returns (Group): The group that is the current group after the pointer has moved.
		public method Group RemoveCurrentOrder {
			private ["_currentIndex" as Scalar, "_currentGroup" as Group];
			
			_currentIndex = _mCurrentIndex;
			_currentGroup = grpNull;
			
			while { _currentIndex >= 0 && (isNull _currentGroup || { count units _currentGroup == 0 }) } do
			{
				if (count _mGroups == 1) then {
					_mGroups = [];
					_currentIndex = -1;
				}
				else {
					_mGroups = [_mGroups, _currentIndex] call ArrayHandler.RemoveItemAtIndex;
					
					if (_currentIndex > count _mGroups - 1) then {
						_currentIndex = 0;
					};
					
					_currentGroup = _mGroups select _currentIndex;
				};
			};
			
			_self.CurrentOrder = _currentGroup;
			_currentGroup
		};
	};
};
