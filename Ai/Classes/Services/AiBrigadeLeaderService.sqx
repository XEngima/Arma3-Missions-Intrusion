/*
 * Name:	AiBrigadeLeaderService
 * Date:	2019-09-30
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * A class that models an AI brigade leader, making decisions and giving orders.
 */

using Sqx.Services;
using Intrusion.Common;
using Intrusion.Server;
using Intrusion.Communication;

namespace Intrusion.Ai
{
	public class AiBrigadeLeaderService : Service
	{
		private fields ["_mSide" as Side, "_mSquadHandler" as ISquadHandler, "_mObservationHandler" as ObservationHandler, "_mMessageHandler" as IMessageHandler, "_mMapMarkersConfig" as IMapMarkersConfig, "_mVehicleSpawner" as IVehicleSpawner, "_mBaseConfig" as BaseConfig, "_mMissionTime" as IMissionTime];
		
		public constructor("_side" as Side, "_resourceLocationHandler" as IResourceLocationHandler, "_squadHandler" as ISquadHandler, "_observationHandler" as ObservationHandler, "_messageHandler" as IMessageHandler, "_mapMarkersConfig" as IMapMarkersConfig, "_vehicleSpawner" as IVehicleSpawner, "_baseConfig" as BaseConfig, "_missionTime" as IMissionTime)
		{
			call _base.Constructor;
			
			_mSide = _side;
			_mSquadHandler = _squadHandler;
			_mObservationHandler = _observationHandler;
			_mMessageHandler = _messageHandler;
			_mMapMarkersConfig = _mapMarkersConfig;
			_mVehicleSpawner = _vehicleSpawner;
			_mBaseConfig = _baseConfig;
			_mMissionTime = _missionTime;
		};
		
		// Finds a new base position around a given position.
		// _markPos (Array): The position where to find a base position.
		// _initialRadius (Scalar): Optional. The initial radius how far from the position that is ok. This
		// value will expand until a position is found.
		private static method Array FindBasePos("_markPos" as Array, ["_initialRadius" as Scalar, 0])
		{
			private ["_roads" as Array, "_spawnpos", "_randir", "_extendedRadius", "_randis", "_houses", "_vehicles", "_isFlat", "_danger", "_foundIt", "_tries"];
			private ["_distanceToNearestVehicle" as Scalar, "_distanceFromBuilding" as Scalar, "_allowedSteepness" as Scalar];
			
			_distanceFromBuilding = 25;
			_allowedSteepness = 0.5;
			_distanceToNearestVehicle = 15;
			
			_spawnpos = [];
			_foundIt = false;
			_tries = 0;
			_extendedRadius = 0;
			
			while { true } do
			{
				scopeName "SpawnPosGen";
				
				_randir = floor random 360;
				_randis = _initialRadius + floor random _extendedRadius;
				_spawnpos = [(_markpos select 0) + ((sin _randir) * _randis), (_markpos select 1) + ((cos _randir) * _randis), 0.1];
				_houses = nearestObjects [_spawnpos, ["house","wall"], 50];
				_vehicles = nearestObjects [_spawnpos, ["LandVehicle", "AirVehicle"], 25];
				_roads = _spawnpos nearRoads _distanceFromBuilding;
				_isFlat = _spawnpos isFlatEmpty [2, -1, _allowedSteepness, 10, 0, false, objNull ];
				
				_danger = false;
				
				private _trees = []; 
				{
				    if (str _x find ": t_" > -1) then {
				        _trees pushBack _x;
				    };
				} forEach nearestObjects [_spawnpos, [], 30];
				
				{ if (floor(_spawnpos distance getPos _x) < _distanceFromBuilding) then { _danger = true; }; } forEach _houses;
				{ if (floor(_spawnpos distance getPos _x) < _distanceToNearestVehicle) then { _danger = true; }; } forEach _vehicles;
				if (count _roads > 0) then { _danger = true; };
				if (count _trees > 10) then { _danger = true; };
				
				if (surfaceIsWater _spawnpos) then { _danger = true; };
				if (count _isFlat < 1 ) then { _danger = true; };
				
				if (!_danger) then { 
					_foundIt = true;
					breakOut "SpawnPosGen"
				};
				
				_tries = _tries + 1;
				_extendedRadius = _extendedRadius + 1;
				
				sleep 0.01;
			};
			
			if (!_foundIt) then {
				_spawnPos = [];
			};
			
			_spawnpos
		};
		
		protected override method Run()
		{
			private ["_moveBaseService" as MoveBaseService, "_baseLayout" as BaseLayout, "_carParkPos" as Array];
			private ["_locationCollection" as ResourceLocationCollection, "_winnerLocation" as ResourceLocation];
			
			_moveBaseService = classNull;
			
			while { !(call PublicVariableHandler.ResourceLocationCollectionHasValue) } do {
				_locationCollection = call PublicVariableHandler.GetResourceLocationCollection;
				sleep 1;
			};
			
			_winnerLocation = call _locationCollection.GetWinnersLocation;
			private _winnerLocationPos = getMarkerPos _winnerLocation.MarkerName;
			private _basePos = _winnerLocationPos getPos [150, random 360];
			
			while { !_self.IsCancelling } do
			{
				if ((call _mMissionTime.GetMissionTime) > 30 && isNull _moveBaseService) then
				{
					_carParkPos = [_basePos] call _self.FindBasePos;
					private _dir = random 360;
					
					_baseLayout = [
						[_carParkPos getPos [30, _dir], _dir + 180] new ViewPos,
						[_carParkPos, _dir + 180] new ViewPos,
						[_carParkPos getPos [20, _dir], _dir + 180] new ViewPos,
					] new BaseLayout;
				
					_moveBaseService = [_mSide, _baseLayout, _mMessageHandler, _mMapMarkersConfig, _mVehicleSpawner, _mBaseConfig] new MoveBaseService;
					call _moveBaseService.RunAsync;
				};
				
				sleep 1;
			};
			
			call _base.Run;
		};
	};
};
