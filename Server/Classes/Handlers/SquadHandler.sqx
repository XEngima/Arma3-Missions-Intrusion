/*
 * Name:	SquadHandler
 * Date:	2017-11-30
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Handles all about groups on the server.
 */

using Intrusion.Common; 

namespace Intrusion.Server
{
	public class SquadHandler
	{
		//private static fields ["_mGroupProfessionCollection" as PlayerGroupCollection];
		private static fields ["_mSquads" as Array /* of Squad */];
		private static fields ["_mProfessionChangeListeners" as Array /* of Code */];
		private static fields ["_mLockedById" as Scalar];
		
		// Initializes the SquadHandler object.
		public static method Init {
			_mLockedById = 0;
			_mSquads = [];
		};
		
		// Gets a group by its leader.
		// _leader: The player object whose group to find.
		// Returns: A player group. classNull if no group was found.
		public static method Squad GetGroupByLeader {
			params ["_leader" as Object];
			private "_foundSquad" as Squad;
			
			scopeName "main";
			_foundSquad = classNull;
			
			{
				_x = _x as Squad;
				if (leader _x.Group == _leader) then {
					_foundSquad = _x;
					breakTo "main";
				};
			} foreach _mSquads as Squad;
			
			_foundSquad
		};
		
		// Called when a leader invites a player to his/her group.
		// _leader: The leader of the group.
		// _member: The member that was invited.
		public static method OnPlayerAddedToGroup {
			//params ["_leader" as Object];
			//private "_member" as Squad;
			
			//_group = [_leader] call _self.GetGroupByLeader;
		};
		
		// Registers a group change profession listener to the list of listeners.
		// _listener (IGroupChangingProfessionListener): The object that will listen.
		public static method RegisterGroupChangingProfessionListener {
			params ["_listener" as IGroupChangingProfessionListener];
			_mProfessionChangeListeners pushBack _listener;
		};
		
		// Adds a new or updates an existing squad.
		// _squad (Squad): The squad to add or update.
		private static method AddOrUpdateSquad {
			params ["_squad" as Squad];
			
			scopeName "main";

			for "_i" from 0 to count _mSquads do 
			{
				private ["_existingSquad" as Squad];
				
				_existingSquad = _mSquads select _i;
				
				if (_existingSquad.Group == _squad.Group) then {
					_mSquads set [_i, _squad];
					breakOut "main";
				};
			};
			
			_mSquads pushBack _squad;
		};
		
		// Removes all empty squads.
		private static method RemoveEmptySquads {
			private ["_squadsToKeep" as Array];
			
			_squadsToKeep = [];
		
			{
				if (!(call _x.IsEmpty)) then {
					_squadsToKeep pushBack _x;
				};
			} foreach _mSquads as Squad;
			
			_mSquads = _squadsToKeep;
		};
		
		// Aquires a lock that prevents other threads to change the squads simultaneously.
		public static method AquireLock {
			// Check that no other thread is currently making changes to the squads.
			while { _mLockedById != 0 } do { sleep 0.01; };
			_mLockedById = 1;
		};
		
		// Releases the lock set by AquireLock so that other threads can make changes to squads.
		public static method ReleaseLock {
			_mLockedById = 0;
		};
		
		// Sets a group's profession to the public variable property.
		// This function aquires a lock during runtime.
		// _group (Group): The group to change profession.
		// _professionName (String): The name of the new profession.
		public static method SetSquadProfession {
			params ["_group" as Group, "_professionType" as ProfessionType];
			private ["_squad" as Squad];
			[(str _this) + " SquadHandler.SetSquadProfession"] call LogHandler.Debug;
			
			call SquadHandler.AquireLock;
			
			// Create a new squad and add (or update) it to the list of squads.
			_squad = [_group, _professionType] new Squad;
			[_squad] call SquadHandler.AddOrUpdateSquad;
			
			call SquadHandler.RemoveEmptySquads;
			
			// Notify all local group change profession listeners.
			{
				[_group, _professionType] call _x.OnGroupChangingProfession;
			} foreach _mProfessionChangeListeners as IGroupChangingProfessionListener;
			
			// Tell the clients about the change
			["ClientSquadHandler.OnGroupProfessionChanged", [_group, _professionType]] call Remote.Invoke;
			
			call SquadHandler.ReleaseLock;
		};
	};
};
