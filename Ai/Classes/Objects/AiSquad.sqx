/*
 * Name:	AiSquad
 * Date:	2019-02-19
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Models an AI squad.
 */

using Intrusion.Common;
using Intrusion.Server;
using Sqx.Collections;
using Sqx.Waypoints;

namespace Intrusion.Ai
{
	public class AiSquad
	{
		private fields ["_mMapMarkerInfo" as MapMarkerInfo, "_mVehicle" as Object, "_mCurrentOrder" as Order, "_mVehicleSpawner" as IVehicleSpawner];
		private fields ["_mState" as AiSquadState, "_mCurrentActionTimeoutTime" as Scalar, "_mUnit" as Object, "_mResourceLocation" as ResourceLocation, "_mUnitInfo" as AiUnitInfo];
		private fields ["_mVehicleIsSquadVehicle" as Boolean, "_mMovingToPos" as Array, "_mLastPos" as Array, "_mLastPosTime" as Scalar];
		
		// Creates an AiSquad object.
		// _noOfUnits (Scalar): Number of units to spawn.
		public constructor("_unitsConfig" as IAiUnitsConfig, "_mapMarkersConfig" as IMapMarkersConfig, "_vehicleSpawner" as IVehicleSpawner, "_side" as Side, "_noOfUnits" as Scalar, "_skillLevel" as SkillLevel)
		{
			_mMapMarkerInfo = [_side] call _mapMarkersConfig.GetMapMarkerInfo;
			_mVehicleSpawner = _vehicleSpawner;
			_mUnitInfo = [_side] call _unitsConfig.GetUnitInfo;
			_self.Group = createGroup _side;
			_mState = AiSquadState.Idle;
			_mVehicle = objNull;
			_mCurrentActionTimeoutTime = time;
			_mCurrentOrder = classNull;
			_mUnit = objNull;
			_mResourceLocation = classNull;
			_mVehicleIsSquadVehicle = false;
			_mMovingToPos = getMarkerPos _mMapMarkerInfo.BaseMarkerName;
			_mLastPos = [];
			_mLastPosTime = 0;
			
			for "_i" from 1 to _noOfUnits do {
				_mUnitInfo.UnitClassName createUnit [getMarkerPos _mMapMarkerInfo.BaseMarkerName, _self.Group];
			};
			
			{
				_x setSkill ([_skillLevel] call SkillLevelMeta.SkillToScalar);
				_x setVariable ["IsAiUnit", true];
			} foreach units _self.Group;
		};
		
		// Gets the AI squad's group.
		public property Group Group { get; private set; };
		
		// Updates the tracking information of the squad.
		private method UpdateTracking()
		{
			private ["_leaderPos" as Array];
			
			_leaderPos = getPos leader _self.Group;
		
			if (!(_mLastPos isEqualTo _leaderPos)) then {
				_mLastPos = getPos leader _self.Group;
				_mLastPosTime = time;
			};
			
			if (time > _mLastPosTime + 60) then {
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
				[AiSquadState.Idle, 0] call _self.SetState;
				player sideChat "Movement timeout. Idle...";
			};
		};
		
		// Gets the team member closest to a position.
		// Returns (Object): The closest team member. objNull if no unit that can stand was found or if the group is empty.
		private method Object GetClosestTeamMember("_pos" as Array)
		{
			private ["_closestUnit" as Object, "_closestDistance" as Scalar];
			
			_closestDistance = 99999999;
			_closestUnit = objNull;
			
			{
				if (canStand _x && _x distance _pos < _closestDistance) then {
					_closestUnit = _x;
					_closestDistance = _x distance _pos;
				};
			} foreach units _self.Group;
			
			_closestUnit
		};
		
		private method CreateOrderOnOwnInitiative()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection, "_location" as ResourceLocation, "_locations" as Array /* of ResourceLocation */, "_valuedLocations" as Array /* of ValuedObject */];
			private ["_count" as Scalar, "_index" as Scalar];
			
			waitUntil { call PublicVariableHandler.ResourceLocationCollectionHasValue };
			
			_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;

			if (MissionCounterService.RemainingMinutes <= 12) then {
				player sideChat "less than 12!";
				
				_location = ResourceLocationHandler.WinnersLocation;
				
				if (isNull _mResourceLocation || {_location.MarkerName != _mResourceLocation.MarkerName}) then {
					_mResourceLocation = _location;
					_mCurrentOrder = [_self.Group, OrderType.Attack, getMarkerPos _location.MarkerName] new Order;
					//_mOrderTime = time;
					[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
					player sideChat "End location order!";
				};
			}
			else {
				// Find the three enemny (or neutral) resource locations closest to the base and select a random one of them.
				
				_locations = call _resourceLocationCollection.GetResourceLocations;
				_count = 0;
				_valuedLocations = [];
				
				{
					_location = _x;
					
					if (_location.Side != side _self.Group) then {
						_valuedLocations pushBack [_location, getMarkerPos _location.MarkerName distance getMarkerPos _mMapMarkerInfo.BaseMarkerName] new ValuedObject;
						_count = _count + 1;
					};
				} foreach _locations as ResourceLocation;
				
				_valuedLocations = [_valuedLocations] call Sorter.QSort;
				
				if (_count > 3) then {
					_count = 3;
				};
				
				if (_count > 0) then {
					_index = floor random _count;
					_location = ((_valuedLocations select _index) as ValuedObject).Object as ResourceLocation;
					
					_mResourceLocation = _location;
					_mCurrentOrder = [_self.Group, OrderType.Attack, getMarkerPos _location.MarkerName] new Order;
					//_mOrderTime = time;
					[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
				};
				
				// If there is no flags to capture, maybe one can chose to defend one instead.
			};
		};
		
		private method ExitVehicle()
		{
			{
				if (!isNull assignedVehicle _x) then {
					unassignVehicle _x;
					moveOut _x;
				};
			} foreach units _self.Group;
		};
		
		private method EnterVehicle("_vehicle" as Object)
		{
			_mVehicle = _vehicle;
			
			{
				if (isNull (assignedVehicle _x) && isNull (assignedDriver _vehicle)) then {
					_x assignAsDriver _vehicle;
					[_x] orderGetIn true;
				};
				if (isNull (assignedVehicle _x) && isNull (assignedCommander _vehicle)) then {
					_x assignAsCommander _vehicle;
					[_x] orderGetIn true;
				};
				if (isNull (assignedVehicle _x) && isNull (assignedGunner _vehicle)) then {
					_x assignAsGunner _vehicle;
					[_x] orderGetIn true;
				};
				if (isNull (assignedVehicle _x)) then {
					_x assignAsCargo _vehicle;
					[_x] orderGetIn true;
				};
			} foreach units _self.Group;
		};
		
		private method SetState("_state" as AiSquadState, "_timeoutTime" as Scalar)
		{
			_mState = _state;
			_mCurrentActionTimeoutTime = time + _timeoutTime;
			
			if (_state == AiSquadState.Idle) then {
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
			};
		};
		
		private method SetIdleIfActionTimedOut()
		{
			if (_mState != AiSquadState.Idle && time > _mCurrentActionTimeoutTime) then {
				[AiSquadState.Idle, 0] call _self.SetState;
				player sideChat "Timeout. Idle...";
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
			};
		};
		
		private method Boolean WholeGroupInVehicle()
		{
			scopeName "main";
		
			{
				if (vehicle _x == _x) then {
					false breakOut "main";
				};
			} foreach units _self.Group;
			
			true
		};
		
		private method Boolean WholeGroupOutOfVehicle()
		{
			scopeName "main";
		
			{
				if (vehicle _x != _x) then {
					false breakOut "main";
				};
			} foreach units _self.Group;
			
			true
		};
		
		private method MakeNewDecision()
		{
			private ["_nearestIntrusionVehicle" as IntrusionVehicle, "_waypoint" as Array, "_location" as ResourceLocation, "_resourceLocationCollection" as ResourceLocationCollection];
			
			scopeName "main";

			_mUnit = [_mCurrentOrder.TargetPosition] call _self.GetClosestTeamMember;
			
			if (!isNull _mUnit) then
			{
				private ["_targets" as Array, "_seeEnemies" as Boolean, "_targetSide" as Side];
				_seeEnemies = false;
				
				// If infantry have see enemy targets, get out of vehicle
				
				if (call _self.WholeGroupInVehicle && !_mVehicleIsSquadVehicle) then {
					_targets = (leader _self.Group) nearTargets 250;
					{
						_targetSide = _x select 2;
						if (([side _self.Group, _targetSide] call BIS_fnc_sideIsEnemy)) then {
							_seeEnemies = true;
						};
					} foreach _targets;
					
					if (_seeEnemies) then {
						[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
						[AiSquadState.ExitingVehicle, 20] call _self.SetState;
						player sideChat "Exiting vehicle #3";
						breakOut "main";
					};
				};
				
				// if within 30 meters of enemy flag, have a unit go get it.
				
				_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;
				_location = [getPos vehicle _mUnit] call _resourceLocationCollection.GetClosestResourceLocation;
				if (!isNull _location && { _location.Side != side _self.Group && vehicle _mUnit distance getMarkerPos _location.MarkerName < 30 }) then
				{
					if (_mVehicleIsSquadVehicle && !isNull driver _mVehicle) then {
						_mUnit = driver _mVehicle;
						unassignVehicle _mUnit;
						[_mUnit] orderGetIn false;
					}
					else {
						if (vehicle _mUnit != _mUnit) then {
							[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
							[AiSquadState.ExitingVehicle, 20] call _self.SetState;
							player sideChat "Exiting vehicle #1";
						};
					};
					
					_mUnit doMove getPos _mResourceLocation.Flag;
					_mUnit setBehaviour "AWARE";
					[AiSquadState.SingleUnitGettingFlag, 30] call _self.SetState;
					player sideChat "SingleUnitGettingFlag";
					
					[_mUnit, getMarkerPos _mResourceLocation.MarkerName] spawn {
						params ["_unit" as Object, "_pos" as Array];
						private ["_timeoutTime" as Scalar];
						
						_timeoutTime = time + 30;
						waitUntil { getPos vehicle _unit distance _pos < 5 || time > _timeoutTime };
						
						if (getPos vehicle _unit distance _pos < 5) then {
							doStop _unit;
						};
					};
					
					breakOut "main";
				};
				
				// If squad is unmounted and have their intrusion vehicle, board it
				
				if (!(call _self.WholeGroupInVehicle) && _mVehicleIsSquadVehicle && alive _mVehicle) then {
					if ([_mVehicle] call _self.GroupFitInVehicle) then {
						[_mVehicle] call _self.EnterVehicle;
						[AiSquadState.BoardingVehicle, 30] call _self.SetState;
						player sideChat "Entering vehicle";
						breakOut "main";
					};
				};
				
				// If within 100 meters from any order's target position, and in a vehicle, stop and get out
				
				if (!_mVehicleIsSquadVehicle) then {
					if (vehicle _mUnit distance _mCurrentOrder.TargetPosition < 100 && vehicle _mUnit != _mUnit) then
					{
						[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
						[AiSquadState.ExitingVehicle, 20] call _self.SetState;
						player sideChat "Exiting vehicle #2";
						breakOut "main";
					};
				};

				// If within 200 meters from enemy flag, or in a vehicle, then move towards the flag.
				
				if (vehicle _mUnit distance _mCurrentOrder.TargetPosition < 200 || vehicle _mUnit != _mUnit) then
				{
					_mMovingToPos = _mCurrentOrder.TargetPosition;
					_waypoint = _self.Group addWaypoint [_mMovingToPos, 10];
					_waypoint setWaypointSpeed "LIMITED";
					_waypoint setWaypointType "HOLD";
					_self.Group setSpeedMode "LIMITED";
					[AiSquadState.Moving, 120] call _self.SetState;
					player sideChat "Moving";
					breakOut "main";
				};
				
				// If there is a vehicle nearby and no enemies, and group fit, then board it.
				
				if (!_seeEnemies) then {
					_nearestIntrusionVehicle = [side _self.Group, getPos leader _self.Group] call _mVehicleSpawner.GetNearestEmptyFreeVehicle;
					
					if (!isNull _nearestIntrusionVehicle && { (leader _self.Group) distance _nearestIntrusionVehicle.Vehicle < 500 }) then {
						if ([_nearestIntrusionVehicle.Vehicle] call _self.GroupFitInVehicle) then {
							[_nearestIntrusionVehicle.Vehicle] call _self.EnterVehicle;
							[AiSquadState.BoardingVehicle, 60] call _self.SetState;
							player sideChat "BoardingVehicle";
							breakOut "main";
						};
					};
				};
				
				// If within 1500 meters from enemy flag, then move towards the flag.
				
				if (vehicle _mUnit distance _mCurrentOrder.TargetPosition < 1500) then
				{
					_mMovingToPos = _mCurrentOrder.TargetPosition;
					_waypoint = _self.Group addWaypoint [_mMovingToPos, 10];
					_waypoint setWaypointSpeed "NORMAL";
					_waypoint setWaypointType "HOLD";
					_self.Group setSpeedMode "NORMAL";
					[AiSquadState.Moving, 600] call _self.SetState;
					player sideChat "Moving #3";
					breakOut "main";
				};
				
				// Else: Move to the car park.
				
				_mMovingToPos = getMarkerPos _mMapMarkerInfo.CarParkMarkerName;
				_waypoint = _self.Group addWaypoint [_mMovingToPos, 25];
				_waypoint setWaypointSpeed "NORMAL";
				_waypoint setWaypointType "HOLD";
				_self.Group setSpeedMode "NORMAL";
				[AiSquadState.Moving, 120] call _self.SetState;
				player sideChat "Moving #2";
				breakOut "main";
			};
		};
		
		private method Boolean GroupFitInVehicle("_vehicle" as Object)
		{
			private ["_crewPlacesCount" as Scalar, "_groupFit" as Boolean];
			
			_crewPlacesCount = (count fullCrew [_vehicle, "driver", true]) + (count fullCrew [_vehicle, "commander", true] + (count fullCrew [_vehicle, "gunner", true]) + (count fullCrew [_vehicle, "turret", true]) + (count fullCrew [_vehicle, "cargo", true]));
			_groupFit = count units _self.Group <= _crewPlacesCount;
			
			_groupFit
		};
		
		private method CheckIfFinishedSingleUnitGettingFlag()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection, "_location" as ResourceLocation];
			_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;
			_location = [getPos vehicle _mUnit] call _resourceLocationCollection.GetClosestResourceLocation;

			{
				if (_x distance2D _location.Flag < 10) then {
					if (alive _x && _location.Side != side _self.Group) then {
						[_location.MarkerName, side _self.Group] call ResourceLocationHandler.SetNewFlagOwner;
					};
					
					[AiSquadState.Idle, 0] call _self.SetState;
					player sideChat "Idle";
				};
			} foreach units _self.Group;
		};
		
		private method CheckIfFinishedMoving()
		{
			private ["_targetDistance" as Scalar];
			
			_targetDistance = 3;
			if (call _self.WholeGroupInVehicle) then {
				_targetDistance = 100;
			};
			if (_mVehicleIsSquadVehicle) then {
				_targetDistance = 15;
			};
		
			if (vehicle _mUnit distance _mMovingToPos < _targetDistance) then {
				[AiSquadState.Idle, 0] call _self.SetState;
				player sideChat "Finished moving. Idle...";
			};
		};
		
		private method CheckIfFinishedBoardingVehicle()
		{
			if ({ vehicle _x == _mVehicle } count units _self.Group == count units _self.Group) then {
				[AiSquadState.Idle, 0] call _self.SetState;
			};
		};
		
		private method CheckIfFinishedExitingVehicle()
		{
			if (call _self.WholeGroupOutOfVehicle) then {
				[AiSquadState.Idle, 0] call _self.SetState;
			};
		};
		
		private method AssistExitingVehicle()
		{
			_mVehicle forceSpeed 0;
			if (speed _mVehicle < 0.1) then {
				_mVehicle forceSpeed -1;
				call _self.ExitVehicle;
			};
		};
		
		private method RespawnIfDead()
		{
			private ["_alive" as Boolean, "_oldUnits" as Array];
			
			_alive = true;
			if ({canMove _x} count units _self.Group == 0) then {
				_alive = false;
			};
			
			if (!_alive) then {
				_oldUnits = units _self.Group;
				
				for "_i" from 1 to (count _oldUnits) do {
					_mUnitInfo.UnitClassName createUnit [getMarkerPos _mMapMarkerInfo.BaseMarkerName, _self.Group];
				};
				
				{
					_x setDamage 1;
					_x setVariable ["IsAiUnit", false];
				} foreach _oldUnits;
				
				(_oldUnits) joinSilent grpNull;
				
				{
					_x setVariable ["IsAiUnit", true];
				} foreach units _self.Group;
				
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
				_mState = AiSquadState.Idle;
			};
		};
		
		private method BeamToBaseIfSquadVehicleIsThere()
		{
			private ["_vehicles" as Array, "_vehicle" as IntrusionVehicle, "_driverSeats" as Array, "_commanderSeats" as Array, "_gunnerSeats" as Array ];
			private ["_driverIn" as Boolean, "_commanderIn" as Boolean, "_gunnerIn" as Boolean, "_unit" as Object, "_basePos" as Array];
			
			_vehicles = [_self.Group] call _mVehicleSpawner.GetIntrusionVehiclesByGroup;
			
			if (count _vehicles > 0) then {
				_vehicle = _vehicles select 0;
				
				_basePos = getMarkerPos _mMapMarkerInfo.BaseMarkerName;
				_unit = [_basePos] call _self.GetClosestTeamMember;

				if (((vehicle _unit) distance _basePos) > 200 && (_vehicle.Vehicle distance _basePos) < 150) then {
					_driverIn = false;
					_commanderIn = false;
					_gunnerIn = false;
					
					_driverSeats = fullCrew [_vehicle.Vehicle, "driver", true];
					_commanderSeats = fullCrew [_vehicle.Vehicle, "commander", true];
					_gunnerSeats = fullCrew [_vehicle.Vehicle, "gunner", true];

					{
						_x setPos _basePos;
						
						if (!_driverIn && count _driverSeats > 0) then {
							_x assignAsDriver _vehicle.Vehicle;
							[_x] orderGetIn true;
							_driverIn = true;
						}
						else {
							if (!_commanderIn && count _commanderSeats > 0) then {
								_x assignAsCommander _vehicle.Vehicle;
								[_x] orderGetIn true;
								_commanderIn = true;
							}
							else {
								if (!_gunnerIn && count _gunnerSeats > 0) then {
									_x assignAsGunner _vehicle.Vehicle;
									[_x] orderGetIn true;
									_gunnerIn = true;
								}
								else {
									_x assignAsCargo _vehicle.Vehicle;
									[_x] orderGetIn true;
								};
							};
						};
					} foreach units _self.Group;
					
					_mVehicle = _vehicle.Vehicle;
					_mVehicleIsSquadVehicle = true;
					[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
					[AiSquadState.BoardingVehicle, 90] call _self.SetState;
					call _self.CreateOrderOnOwnInitiative;
					player sideChat "Beaming. Idle...";
				};
			};
		};
		
		private method UpdateOrder()
		{
			if (MissionCounterService.RemainingMinutes <= 12) then {
				call _self.CreateOrderOnOwnInitiative;
			}
			else {
				if (isNull _mCurrentOrder) then {
					call _self.CreateOrderOnOwnInitiative;
					player sideChat "new order #1.";
				}
				else {
					// If flag at order target location is friendly, set a new order
					if (_mResourceLocation.Side == side _self.Group) then {
						call _self.CreateOrderOnOwnInitiative;
						player sideChat "new order #2.";
					}
				};
			};
		};
		
		private method UpdateTargetResourceLocation()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection];
			
			if (!isNull _mResourceLocation) then {
				_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;
				_mResourceLocation = [_mResourceLocation.MarkerName] call _resourceLocationCollection.GetResourceLocationByMarkerName;
			};
		};
		
		// Gives the AI squad an opportunity to act.
		public method Act()
		{
			call _self.UpdateTracking;
			call _self.UpdateTargetResourceLocation;
			call _self.RespawnIfDead;
			call _self.SetIdleIfActionTimedOut;
			
			if (_mState == AiSquadState.Idle) then {
				call _self.BeamToBaseIfSquadVehicleIsThere;
				call _self.UpdateOrder;
			};
			
			if (_mState == AiSquadState.Idle && !isNull _mVehicle && { !alive _mVehicle }) then {
				call _self.ExitVehicle;
				_mVehicle = objNull;
				_mVehicleIsSquadVehicle = false;
			};
			
			switch (_mState) do {
				case AiSquadState.ExitingVehicle: { call _self.AssistExitingVehicle; };
			};
			
			switch (_mState) do {
				case AiSquadState.Idle: { call _self.MakeNewDecision; };
				case AiSquadState.SingleUnitGettingFlag: { call _self.CheckIfFinishedSingleUnitGettingFlag; };
				case AiSquadState.Moving: { call _self.CheckIfFinishedMoving; };
				case AiSquadState.BoardingVehicle: { call _self.CheckIfFinishedBoardingVehicle; };
				case AiSquadState.ExitingVehicle: { call _self.CheckIfFinishedExitingVehicle; };
			};
		};
	};
};
