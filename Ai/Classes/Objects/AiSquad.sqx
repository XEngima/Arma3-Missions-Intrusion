/*
 * Name:	AiSquad
 * Date:	2019-02-19
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Models an AI squad.
 */

using Intrusion.Common;
using Intrusion.Server;
using Sqx.Collections;
using Sqx.Waypoints;

namespace Intrusion.Ai
{
	public class AiSquadOld
	{
		private fields ["_mMapMarkerInfo" as MapMarkerInfo, "_mVehicle" as Object, "_mCurrentOrder" as Order, "_mVehicleSpawner" as IVehicleSpawner, "_mUnitSpawner" as IUnitSpawner];
		private fields ["_mState" as AiSquadState, "_mCurrentActionTimeoutTime" as Scalar, "_mUnit" as Object, "_mResourceLocation" as ResourceLocation, "_mUnitInfo" as AiUnitInfo];
		private fields ["_mVehicleIsSquadVehicle" as Boolean, "_mMovingToPos" as Array, "_mLastPos" as Array, "_mLastPosTime" as Scalar, "_mResourceLocationHandler" as IResourceLocationHandler];
		private fields ["_mInventedTechnologiesCollection" as InventedTechnologiesCollection, "_mProfessionConfig" as ProfessionConfig];
		private fields ["_mWannaBeProfessionType" as ProfessionType, "_mProfessionType" as ProfessionType, "_mSquadHandler" as ISquadHandler, "_mAiWeaponsConfig" as IAiWeaponsConfig];
		private fields ["_mOrderSetByLeader" as Boolean];

		// Creates an AiSquad object.
		// _noOfUnits (Scalar): Number of units to spawn.
		public constructor(
			"_unitsConfig" as IAiUnitsConfig,
			"_professionConfig" as ProfessionConfig,
			"_resourceLocationHandler" as IResourceLocationHandler, 
			"_mapMarkersConfig" as IMapMarkersConfig, 
			"_vehicleSpawner" as IVehicleSpawner, 
			"_side" as Side, 
			"_noOfUnits" as Scalar, 
			"_skillLevel" as SkillLevel, 
			"_inventedTechnologiesCollection" as InventedTechnologiesCollection,
			"_squadHandler" as ISquadHandler,
			"_unitSpawner" as IUnitSpawner,
			"_aiWeaponsConfig" as IAiWeaponsConfig)
		{
			private ["_unit" as Object];
			
			_mProfessionConfig = _professionConfig;
			_mResourceLocationHandler = _resourceLocationHandler;
			_mMapMarkerInfo = [_side] call _mapMarkersConfig.GetMapMarkerInfo;
			_mVehicleSpawner = _vehicleSpawner;
			_mInventedTechnologiesCollection = _inventedTechnologiesCollection;
			_mSquadHandler = _squadHandler;
			_mUnitSpawner = _unitSpawner;
			_mAiWeaponsConfig = _aiWeaponsConfig;
			_mUnitInfo = [_side] call _unitsConfig.GetUnitInfo;
			_self.Group = createGroup _side;
			_mState = AiSquadState.Idle;
			_mVehicle = objNull;
			_mCurrentActionTimeoutTime = time;
			_mCurrentOrder = classNull;
			_mUnit = objNull;
			_mResourceLocation = classNull;
			_mVehicleIsSquadVehicle = false;
			_mMovingToPos = getMarkerPos _mMapMarkerInfo.BaseMarkerName;
			_mLastPos = [];
			_mLastPosTime = 0;
			_mWannaBeProfessionType = ProfessionType.Undefined;
			_mProfessionType = ProfessionType.Undefined;
			_self.Members = [];
			_mOrderSetByLeader = false;
			
			for "_i" from 1 to _noOfUnits do {
				_unit = [_mUnitInfo.UnitClassName, getMarkerPos _mMapMarkerInfo.BaseMarkerName, _self.Group] call _mUnitSpawner.CreateUnit;
				_self.Members pushBack _unit;
			};
		};
		
		// Gets the AI squad's group.
		public property Group Group { get; private set; };
		
		public property Array Members { get; private set; };
		
		// Updates the tracking information of the squad.
		private method UpdateTracking()
		{
			private ["_leaderPos" as Array];
			
			_leaderPos = getPos leader _self.Group;
		
			if (!(_mLastPos isEqualTo _leaderPos)) then {
				_mLastPos = getPos leader _self.Group;
				_mLastPosTime = time;
			};
			
			if (time > _mLastPosTime + 60) then {
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
				[AiSquadState.Idle, 0] call _self.SetState;
//				player sideChat "Movement timeout. Idle...";
			};
		};
		
		// Gets the team member closest to a position.
		// Returns (Object): The closest team member. objNull if no unit that can stand was found or if the group is empty.
		private method Object GetClosestTeamMember("_pos" as Array)
		{
			private ["_closestUnit" as Object, "_closestDistance" as Scalar];
			
			_closestDistance = 99999999;
			_closestUnit = objNull;
			
			{
				if (canStand _x && _x distance _pos < _closestDistance) then {
					_closestUnit = _x;
					_closestDistance = _x distance _pos;
				};
			} foreach units _self.Group;
			
			_closestUnit
		};
		
		private method CreateOrderOnOwnInitiative()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection, "_location" as ResourceLocation, "_locations" as Array /* of ResourceLocation */, "_valuedLocations" as Array /* of ValuedObject */];
			private ["_count" as Scalar, "_index" as Scalar];
			
			if (!_mOrderSetByLeader) then
			{
				waitUntil { call PublicVariableHandler.ResourceLocationCollectionHasValue };
				
				_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;
	
				if (12 <= 12) then {
	//				player sideChat "less than 12!";
					
					_location = _mResourceLocationHandler.WinnersLocation;
					
					if (isNull _mResourceLocation || {_location.MarkerName != _mResourceLocation.MarkerName}) then {
						_mResourceLocation = _location;
						_mCurrentOrder = [_self.Group, OrderType.Attack, getMarkerPos _location.MarkerName, _location] new Order;
						//_mOrderTime = time;
						[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
	//					player sideChat "End location order!";
					};
				}
				else {
					// Find the three enemy (or neutral) resource locations closest to the base and select a random one of them.
					
					_locations = call _resourceLocationCollection.GetResourceLocations;
					_count = 0;
					_valuedLocations = [];
					
					{
						_location = _x;
						
						if (_location.Side != side _self.Group) then {
							_valuedLocations pushBack [_location, getMarkerPos _location.MarkerName distance getMarkerPos _mMapMarkerInfo.BaseMarkerName] new ValuedObject;
							_count = _count + 1;
						};
					} foreach _locations as ResourceLocation;
					
					_valuedLocations = [_valuedLocations] call Sorter.QSort;
					
					if (_count > 3) then {
						_count = 3;
					};
					
					if (_count > 0) then {
						_index = floor random _count;
						_location = ((_valuedLocations select _index) as ValuedObject).Object as ResourceLocation;
						
						_mResourceLocation = _location;
						_mCurrentOrder = [_self.Group, OrderType.Attack, getMarkerPos _location.MarkerName, _location] new Order;
						//_mOrderTime = time;
						[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
					};
					
					// If there is no flags to capture, maybe one can chose to defend one instead.
				};
			};
		};
		
		private method ExitVehicle()
		{
			{
				if (!isNull assignedVehicle _x) then {
					unassignVehicle _x;
					moveOut _x;
				};
			} foreach units _self.Group;
		};
		
		private method EnterVehicle("_vehicle" as Object)
		{
			_mVehicle = _vehicle;
			
			{
				if (isNull (assignedVehicle _x) && isNull (assignedDriver _vehicle)) then {
					_x assignAsDriver _vehicle;
					[_x] orderGetIn true;
				};
				if (isNull (assignedVehicle _x) && isNull (assignedCommander _vehicle)) then {
					_x assignAsCommander _vehicle;
					[_x] orderGetIn true;
				};
				if (isNull (assignedVehicle _x) && isNull (assignedGunner _vehicle)) then {
					_x assignAsGunner _vehicle;
					[_x] orderGetIn true;
				};
				if (isNull (assignedVehicle _x)) then {
					_x assignAsCargo _vehicle;
					[_x] orderGetIn true;
				};
			} foreach units _self.Group;
		};
		
		private method SetState("_state" as AiSquadState, "_timeoutTime" as Scalar)
		{
			_mState = _state;
			_mCurrentActionTimeoutTime = time + _timeoutTime;
			
			if (_state == AiSquadState.Idle) then {
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
			};
		};
		
		private method SetIdleIfActionTimedOut()
		{
			if (_mState != AiSquadState.Idle && time > _mCurrentActionTimeoutTime) then {
				[AiSquadState.Idle, 0] call _self.SetState;
//				player sideChat "Timeout. Idle...";
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
			};
		};
		
		private method Boolean WholeGroupInVehicle()
		{
			scopeName "main";
		
			{
				if (vehicle _x == _x) then {
					false breakOut "main";
				};
			} foreach units _self.Group;
			
			true
		};
		
		private method Boolean WholeGroupOutOfVehicle()
		{
			scopeName "main";
		
			{
				if (vehicle _x != _x) then {
					false breakOut "main";
				};
			} foreach units _self.Group;
			
			true
		};
		
		private method MakeNewDecision()
		{
			private ["_nearestIntrusionVehicle" as IntrusionVehicle, "_waypoint" as Array, "_location" as ResourceLocation, "_resourceLocationCollection" as ResourceLocationCollection];
			
			scopeName "main";

			_mUnit = [_mCurrentOrder.TargetPosition] call _self.GetClosestTeamMember;
			
			if (!isNull _mUnit) then
			{
				private ["_targets" as Array, "_seeEnemies" as Boolean, "_targetSide" as Side];
				_seeEnemies = false;
				
				// If infantry have seen enemy targets, get out of vehicle
				
				if (call _self.WholeGroupInVehicle && !_mVehicleIsSquadVehicle) then {
					_targets = (leader _self.Group) nearTargets 250;
					{
						_targetSide = _x select 2;
						if (([side _self.Group, _targetSide] call BIS_fnc_sideIsEnemy)) then {
							_seeEnemies = true;
						};
					} foreach _targets;
					
					if (_seeEnemies) then {
						[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
						[AiSquadState.ExitingVehicle, 20] call _self.SetState;
//						player sideChat "Exiting vehicle #3";
						breakOut "main";
					};
				};
				
				// if within 30 meters of enemy flag, have a unit go get it.
				
				_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;
				_location = [getPos vehicle _mUnit] call _resourceLocationCollection.GetClosestResourceLocation;
				if (!isNull _location && { _location.Side != side _self.Group && vehicle _mUnit distance getMarkerPos _location.MarkerName < 30 }) then
				{
					if (_mVehicleIsSquadVehicle && !isNull driver _mVehicle) then {
						_mUnit = driver _mVehicle;
						unassignVehicle _mUnit;
						[_mUnit] orderGetIn false;
					}
					else {
						if (vehicle _mUnit != _mUnit) then {
							[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
							[AiSquadState.ExitingVehicle, 20] call _self.SetState;
//							player sideChat "Exiting vehicle #1";
						};
					};
					
					_mUnit doMove getPos _mResourceLocation.Flag;
					_mUnit setBehaviour "AWARE";
					//[AiSquadState.SingleUnitGettingFlag, 30] call _self.SetState;
//					player sideChat "SingleUnitGettingFlag";
					
					[_mUnit, getMarkerPos _mResourceLocation.MarkerName] spawn {
						params ["_unit" as Object, "_pos" as Array];
						private ["_timeoutTime" as Scalar];
						
						_timeoutTime = time + 30;
						waitUntil { getPos vehicle _unit distance _pos < 5 || time > _timeoutTime };
						
						if (getPos vehicle _unit distance _pos < 5) then {
							doStop _unit;
						};
					};
					
					breakOut "main";
				};
				
				// If squad is unmounted and have their intrusion vehicle, then mount
				
				if (!(call _self.WholeGroupInVehicle) && _mVehicleIsSquadVehicle && alive _mVehicle) then {
					if ([_mVehicle] call _self.GroupFitInVehicle) then {
						[_mVehicle] call _self.EnterVehicle;
						[AiSquadState.MountingVehicle, 30] call _self.SetState;
//						player sideChat "Entering vehicle";
						breakOut "main";
					};
				};
				
				// If within 100 meters from any order's target position, and in a vehicle, stop and get out
				
				if (!_mVehicleIsSquadVehicle) then {
					if (vehicle _mUnit distance _mCurrentOrder.TargetPosition < 100 && vehicle _mUnit != _mUnit) then
					{
						[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
						[AiSquadState.ExitingVehicle, 20] call _self.SetState;
//						player sideChat "Exiting vehicle #2";
						breakOut "main";
					};
				};

				// If within 200 meters from enemy flag, or in a vehicle, then move towards the flag.
				
				if (vehicle _mUnit distance _mCurrentOrder.TargetPosition < 200 || vehicle _mUnit != _mUnit) then
				{
					_mMovingToPos = _mCurrentOrder.TargetPosition;
					_waypoint = _self.Group addWaypoint [_mMovingToPos, 10];
					_waypoint setWaypointSpeed "LIMITED";
					_waypoint setWaypointType "HOLD";
					_self.Group setSpeedMode "LIMITED";
					[AiSquadState.Moving, 120] call _self.SetState;
//					player sideChat "Moving";
					breakOut "main";
				};
				
				// If there is a vehicle nearby and no enemies, and group fit, then mount.
				
				if (!_seeEnemies) then {
					_nearestIntrusionVehicle = [side _self.Group, getPos vehicle leader _self.Group, count _self.Members] call _mVehicleSpawner.GetNearestEmptyFreeVehicle;
					
					if (!isNull _nearestIntrusionVehicle && { (leader _self.Group) distance _nearestIntrusionVehicle.Vehicle < 500 }) then {
						if ([_nearestIntrusionVehicle.Vehicle] call _self.GroupFitInVehicle) then {
							[_nearestIntrusionVehicle.Vehicle] call _self.EnterVehicle;
							[AiSquadState.MountingVehicle, 60] call _self.SetState;
							breakOut "main";
						};
					};
				};
				
				// If within 3000 meters from enemy flag, then move towards the flag.
				
				if (vehicle _mUnit distance _mCurrentOrder.TargetPosition < 3000) then
				{
					_mMovingToPos = _mCurrentOrder.TargetPosition;
					_waypoint = _self.Group addWaypoint [_mMovingToPos, 10];
					_waypoint setWaypointSpeed "NORMAL";
					_waypoint setWaypointType "HOLD";
					_self.Group setSpeedMode "NORMAL";
					[AiSquadState.Moving, 600] call _self.SetState;
//					player sideChat "Moving #3";
					breakOut "main";
				};
				
				// Else: Move to the car park.
				
				_mMovingToPos = getMarkerPos _mMapMarkerInfo.CarParkMarkerName;
				_waypoint = _self.Group addWaypoint [_mMovingToPos, 25];
				_waypoint setWaypointSpeed "NORMAL";
				_waypoint setWaypointType "HOLD";
				_self.Group setSpeedMode "NORMAL";
				[AiSquadState.Moving, 120] call _self.SetState;
//				player sideChat "Moving #2";
				breakOut "main";
			};
		};
		
		private method Boolean GroupFitInVehicle("_vehicle" as Object)
		{
			private ["_crewPlacesCount" as Scalar, "_groupFit" as Boolean];
			
			_crewPlacesCount = (count fullCrew [_vehicle, "driver", true]) + (count fullCrew [_vehicle, "commander", true] + (count fullCrew [_vehicle, "gunner", true]) + (count fullCrew [_vehicle, "turret", true]) + (count fullCrew [_vehicle, "cargo", true]));
			_groupFit = count units _self.Group <= _crewPlacesCount;
			
			_groupFit
		};
		
		private method CheckIfFinishedSingleUnitGettingFlag()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection, "_location" as ResourceLocation];
			_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;
			_location = [getPos vehicle _mUnit] call _resourceLocationCollection.GetClosestResourceLocation;

			{
				if (_x distance2D _location.Flag < 10) then {
					if (alive _x && _location.Side != side _self.Group) then {
						//[_location.Flag, _location.MarkerName, side _self.Group, _x] call ServerEventReciever.OnFlagCaptured;
						//[_location.MarkerName, side _self.Group] call ResourceLocationHandler.SetNewFlagOwner;
					};
					
					[AiSquadState.Idle, 0] call _self.SetState;
//					player sideChat "Idle";
				};
			} foreach units _self.Group;
		};
		
		private method CheckIfFinishedMoving()
		{
			private ["_targetDistance" as Scalar];
			
			_targetDistance = 3;
			if (call _self.WholeGroupInVehicle) then {
				_targetDistance = 100;
			};
			if (_mVehicleIsSquadVehicle) then {
				_targetDistance = 15;
			};
		
			if (vehicle _mUnit distance _mMovingToPos < _targetDistance) then {
				[AiSquadState.Idle, 0] call _self.SetState;
//				player sideChat "Finished moving. Idle...";
			};
		};
		
		private method CheckIfFinishedMountingVehicle()
		{
			if ({ vehicle _x == _mVehicle } count units _self.Group == count units _self.Group) then {
				[AiSquadState.Idle, 0] call _self.SetState;
			};
		};
		
		private method CheckIfFinishedExitingVehicle()
		{
			if (call _self.WholeGroupOutOfVehicle) then {
				[AiSquadState.Idle, 0] call _self.SetState;
			};
		};
		
		private method AssistExitingVehicle()
		{
			_mVehicle forceSpeed 0;
			if (speed _mVehicle < 0.1) then {
				_mVehicle forceSpeed -1;
				call _self.ExitVehicle;
			};
		};
		
		private method RespawnIfDead()
		{
			private ["_anyMemberAlive" as Boolean, "_oldUnits" as Array];
			private ["_aiWeaponInfo" as AiWeaponInfo, "_atLaunchersInvented" as Boolean, "_aaLaunchersInvented" as Boolean];
			
			_anyMemberAlive = true;
			if ({canMove _x} count _self.Members == 0) then {
				_anyMemberAlive = false;
			};
			
			if (!_anyMemberAlive) then {
				_oldUnits = _self.Members;
				
				for "_i" from 1 to (count _oldUnits) do {
					[_mUnitInfo.UnitClassName, getMarkerPos _mMapMarkerInfo.BaseMarkerName, _self.Group] call _mUnitSpawner.CreateUnit;
				};
				
				{
					_x setDamage 1;
				} foreach _oldUnits;
				
				(_oldUnits) joinSilent grpNull;
				
				_self.Members = units _self.Group;
				
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
				
				// Check if launchers are invented, and in that case equip AI with launchers.
				_aiWeaponInfo = [side _self.Group] call _mAiWeaponsConfig.GetWeaponInfo;
				_atLaunchersInvented = [side _self.Group, Technology.Ordnance] call _mInventedTechnologiesCollection.SideTechnologyIsInvented;
				_aaLaunchersInvented = [side _self.Group, Technology.AntiAir] call _mInventedTechnologiesCollection.SideTechnologyIsInvented;
				
				{
					if (_atLaunchersInvented && random 1 > _aiWeaponInfo.ProbabilityAiTakesAtLauncher) then
					{
						_x addBackpack "B_Kitbag_cbr";
						(unitBackpack _x) addMagazineCargo [_aiWeaponInfo.AtLauncherAmmoClassName, 1];
						_x addWeapon _aiWeaponInfo.AtLauncherClassName;
					}
					else {
						if (_aaLaunchersInvented && random 1 > _aiWeaponInfo.ProbabilityAiTakesAaLauncher) then {
							_x addBackpack "B_Kitbag_cbr";
							(unitBackpack _x) addMagazineCargo [_aiWeaponInfo.AaLauncherAmmoClassName, 1];
							_x addWeapon _aiWeaponInfo.AaLauncherClassName;
						};
					
					};
				} foreach _self.Members as Object;

				_mState = AiSquadState.Idle;
			};
		};
		
		private method BeamToBaseIfSquadVehicleIsThere()
		{
			private ["_vehicles" as Array, "_vehicle" as IntrusionVehicle, "_driverSeats" as Array, "_commanderSeats" as Array, "_gunnerSeats" as Array ];
			private ["_driverIn" as Boolean, "_commanderIn" as Boolean, "_gunnerIn" as Boolean, "_unit" as Object, "_basePos" as Array, "_tempGroup" as Group];
			
			_vehicles = [_self.Group] call _mVehicleSpawner.GetIntrusionVehiclesByGroup;
			
			if (count _vehicles > 0) then {
				_vehicle = _vehicles select 0;
				
				_basePos = getMarkerPos _mMapMarkerInfo.BaseMarkerName;
				_unit = [_basePos] call _self.GetClosestTeamMember;

				if (((vehicle _unit) distance _basePos) > 200 && (_vehicle.Vehicle distance _basePos) < 150) then {
					_driverIn = false;
					_commanderIn = false;
					_gunnerIn = false;
					
					_driverSeats = fullCrew [_vehicle.Vehicle, "driver", true];
					_commanderSeats = fullCrew [_vehicle.Vehicle, "commander", true];
					_gunnerSeats = fullCrew [_vehicle.Vehicle, "gunner", true];
					_tempGroup = createGroup side _self.Group;
					
					// Respawn all alive members, and wake up all dead
					{
						if (alive _x) then {
							_x setPos _basePos;
							_x setDamage 0;
						}
						else {
							[_mUnitInfo.UnitClassName, getMarkerPos _mMapMarkerInfo.BaseMarkerName, _tempGroup] call _mUnitSpawner.CreateUnit;
							//_mUnitInfo.UnitClassName createUnit [getMarkerPos _mMapMarkerInfo.BaseMarkerName, _tempGroup];							
						};						
					} foreach _self.Members as Object;
					
					(units _tempGroup) joinSilent _self.Group;
					_self.Members = units _self.Group;
					deleteGroup _tempGroup;

					// Assign the group to the vehicle.
					{
						if (!_driverIn && count _driverSeats > 0) then {
							_x assignAsDriver _vehicle.Vehicle;
							[_x] orderGetIn true;
							_driverIn = true;
						}
						else {
							if (!_commanderIn && count _commanderSeats > 0) then {
								_x assignAsCommander _vehicle.Vehicle;
								[_x] orderGetIn true;
								_commanderIn = true;
							}
							else {
								if (!_gunnerIn && count _gunnerSeats > 0) then {
									_x assignAsGunner _vehicle.Vehicle;
									[_x] orderGetIn true;
									_gunnerIn = true;
								}
								else {
									_x assignAsCargo _vehicle.Vehicle;
									[_x] orderGetIn true;
								};
							};
						};
					} foreach units _self.Group as Object;
					
					_mVehicle = _vehicle.Vehicle;
					_mVehicleIsSquadVehicle = true;
					[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
					[AiSquadState.MountingVehicle, 90] call _self.SetState;
					call _self.CreateOrderOnOwnInitiative;
//					player sideChat "Beaming. Idle...";
				};
			};
		};
		
		private method UpdateOrder()
		{
			if (20 <= 20) then {
				call _self.CreateOrderOnOwnInitiative;
			}
			else {
				if (isNull _mCurrentOrder) then {
					call _self.CreateOrderOnOwnInitiative;
//					player sideChat "new order #1.";
				}
				else {
					// If flag at order target location is friendly, set a new order
					if (_mResourceLocation.Side == side _self.Group) then {
						call _self.CreateOrderOnOwnInitiative;
//						player sideChat "new order #2.";
					}
				};
			};
		};
		
		private method UpdateTargetResourceLocation()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection];
			
			if (!isNull _mResourceLocation) then {
				_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;
				_mResourceLocation = [_mResourceLocation.MarkerName] call _resourceLocationCollection.GetResourceLocationByMarkerName;
			};
		};
		
		// Gets a random an possible to implement profession type for the group.
		// _side (Side): The side of the group.
		// _unitCount (Scalar): The number of units in the group.
		private method ProfessionType GetRandomProfessionType("_side" as Side, "_unitCount" as Scalar)
		{
			private ["_ok" as Boolean, "_professionType" as ProfessionType, "_profession" as Profession, "_squadCollection" as SquadCollection, "_tries" as Scalar];
			
			_ok = false;
			_tries = 0;
			
			while { !_ok && _tries < 25 } do {
				_professionType = selectRandom AiSquadHandler.AiWarriorTypes;
				_profession = [_professionType] call _mProfessionConfig.GetProfession;
				_ok = _unitCount >= _profession.MinGroupSize && (_unitCount <= _profession.MaxGroupSize || _profession.MaxGroupSize == 0);
				
				if (_ok) then {
					_squadCollection = call PublicVariableHandler.GetSquadCollection;
					_ok = [_side, _professionType, _mProfessionConfig] call _squadCollection.ProfessionTypeAvailable;
				};
				
				_tries = _tries + 1;
			};
			
			if (_tries == 25) then {
				_professionType == ProfessionType.Infantry;
			};

			_professionType
		};
		
		// Tries to set the squad's profession if it is still Infantry.
		private method SetSquadProfession()
		{
			private ["_rating" as Scalar];
			private ["_squadCollection" as SquadCollection];
		
			if (_mProfessionType == ProfessionType.Undefined) then
			{
				// Check that the squad has selected the profession type it wants to be.
				if (_mWannaBeProfessionType == ProfessionType.Undefined) then {
					_mWannaBeProfessionType = [side _self.Group, count _self.Members] call _self.GetRandomProfessionType;
				};
				
				// Try to select the wanted profession type
				_squadCollection = call PublicVariableHandler.GetSquadCollection;
				
				if ([side _self.Group, _mWannaBeProfessionType, _mProfessionConfig] call _squadCollection.ProfessionTypeAvailable) then
				{
					_rating = _self.Group getVariable ["Rating", 0];
					
					if ([side _self.Group, _mWannaBeProfessionType, _rating, _mProfessionConfig] call _squadCollection.ProfessionTypeSelectable) then {
						[_self.Group, _mWannaBeProfessionType] call _mSquadHandler.SetSquadProfession;
						_mProfessionType = _mWannaBeProfessionType;
		        		["AI Squad '" + str _self.Group + "' selected profession type '" + str _mProfessionType + "'."] call LogHandler.Debug;
					};
				}
				else {
					// If profession type is not available, then select another profession type
					_mWannaBeProfessionType = [side _self.Group, count _self.Members] call _self.GetRandomProfessionType;
				};
			};
		};
		
		// Gives a new order to the group.
		// _order (Order): The new order.
		public method GiveOrder("_order" as Order)
		{
			_mCurrentOrder = _order;
			_mOrderSetByLeader = true;
			[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
			[AiSquadState.Idle, 0] call _self.SetState;
		};
		
		// Gives the AI squad an opportunity to act.
		public method Act()
		{
			call _self.UpdateTracking;
			call _self.SetSquadProfession;
			call _self.UpdateTargetResourceLocation;
			call _self.RespawnIfDead;
			call _self.SetIdleIfActionTimedOut;
			call _self.BeamToBaseIfSquadVehicleIsThere;
			
			if (_mState == AiSquadState.Idle) then {
				call _self.UpdateOrder;
			};
			
			if (_mState == AiSquadState.Idle && !isNull _mVehicle && { !alive _mVehicle }) then {
				call _self.ExitVehicle;
				_mVehicle = objNull;
				_mVehicleIsSquadVehicle = false;
			};
			
			switch (_mState) do {
				case AiSquadState.ExitingVehicle: { call _self.AssistExitingVehicle; };
			};
			
			switch (_mState) do {
				case AiSquadState.Idle: { call _self.MakeNewDecision; };
				//case AiSquadState.SingleUnitGettingFlag: { call _self.CheckIfFinishedSingleUnitGettingFlag; };
				case AiSquadState.Moving: { call _self.CheckIfFinishedMoving; };
				case AiSquadState.MountingVehicle: { call _self.CheckIfFinishedMountingVehicle; };
				case AiSquadState.ExitingVehicle: { call _self.CheckIfFinishedExitingVehicle; };
			};
		};
	};
};
