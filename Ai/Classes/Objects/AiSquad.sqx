/*
 * Name:	AiSquad
 * Date:	2019-02-19
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Models an AI squad.
 */

using Intrusion.Common;
using Intrusion.Server;
using Sqx.Collections;
using Sqx.Waypoints;

namespace Intrusion.Ai
{
	public class AiSquad
	{
		private fields ["_mMapMarkerInfo" as MapMarkerInfo, "_mVehicle" as Object, "_mCurrentOrder" as Order, "_mOrderTime" as Scalar, "_mVehicleSpawner" as IVehicleSpawner];
		private fields ["_mState" as AiSquadState, "_mCurrentActionTimeoutTime" as Scalar, "_mUnit" as Object, "_mResourceLocation" as ResourceLocation, "_mUnitInfo" as AiUnitInfo];
		private fields ["_mVehicleIsSquadVehicle" as Boolean];
		
		// Creates an AiSquad object.
		// _noOfUnits (Scalar): Number of units to spawn.
		public constructor("_unitsConfig" as IAiUnitsConfig, "_mapMarkersConfig" as IMapMarkersConfig, "_vehicleSpawner" as IVehicleSpawner, "_side" as Side, "_noOfUnits" as Scalar)
		{
			_mMapMarkerInfo = [_side] call _mapMarkersConfig.GetMapMarkerInfo;
			_mVehicleSpawner = _vehicleSpawner;
			_mUnitInfo = [_side] call _unitsConfig.GetUnitInfo;
			_self.Group = createGroup _side;
			_mState = AiSquadState.Idle;
			_mVehicle = objNull;
			_mCurrentActionTimeoutTime = time;
			_mCurrentOrder = classNull;
			_mOrderTime = 0;
			_mUnit = objNull;
			_mResourceLocation = classNull;
			_mVehicleIsSquadVehicle = false;
			
			for "_i" from 1 to _noOfUnits do {
				_mUnitInfo.UnitClassName createUnit [getMarkerPos _mMapMarkerInfo.BaseMarkerName, _self.Group];
			};
		};
		
		// Gets the AI squad's group.
		public property Group Group { get; private set; };
		
		// Updates the tracking information of the squad.
		private method UpdateTracking()
		{
			//_mLeaderPos = getPos vehicle leader _self.Group;
		};
		
		// Gets the team member closest to a position.
		// Returns (Object): The closest team member. objNull if no unit that can stand was found or if the group is empty.
		private method Object GetClosestTeamMember("_pos" as Array)
		{
			private ["_closestUnit" as Object, "_closestDistance" as Scalar];
			
			_closestDistance = 99999999;
			_closestUnit = objNull;
			
			{
				if (canStand _x && _x distance _pos < _closestDistance) then {
					_closestUnit = _x;
					_closestDistance = _x distance _pos;
				};
			} foreach units _self.Group;
			
			_closestUnit
		};
		
		private method CreateOrderOnOwnInitiative()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection, "_location" as ResourceLocation, "_locations" as Array /* of ResourceLocation */, "_valuedLocations" as Array /* of ValuedObject */];
			private ["_count" as Scalar, "_index" as Scalar];
			
			waitUntil { call PublicVariableHandler.ResourceLocationCollectionHasValue };
			
			_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;
			_locations = call _resourceLocationCollection.GetResourceLocations;
			_count = 0;
			
			// Find the three enemny (or neutral) resource locations closest to the base and select a random one of them.
			_valuedLocations = [];
			{
				_location = _x;
				
				if (_location.Side != side _self.Group) then {
					_valuedLocations pushBack [_location, getMarkerPos _location.MarkerName distance getMarkerPos _mMapMarkerInfo.BaseMarkerName] new ValuedObject;
					_count = _count + 1;
				};
			} foreach _locations as ResourceLocation;
			
			_valuedLocations = [_valuedLocations] call Sorter.QSort;
			
			if (_count > 3) then {
				_count = 3;
			};
			
			if (_count > 0) then {
				_index = floor random _count;
				_location = ((_valuedLocations select _index) as ValuedObject).Object as ResourceLocation;
				
				_mResourceLocation = _location;
				_mCurrentOrder = [_self.Group, OrderType.Attack, getMarkerPos _location.MarkerName] new Order;
				_mOrderTime = time;
				
				[getPos _location.Flag] call Sqx.Markers.Marker.CreateIconMarker;
			};
			
			// If there is no flags to capture, maybe one can chose to defend one instead.
		};
		
		private method ExitVehicle()
		{
			{
				if (!isNull assignedVehicle _x) then {
					unassignVehicle _x;
					moveOut _x;
				};
			} foreach units _self.Group;
		};
		
		private method EnterVehicle("_vehicle" as Object)
		{
			_mVehicle = _vehicle;
			
			{
				if (isNull (assignedVehicle _x) && isNull (assignedDriver _vehicle)) then {
					_x assignAsDriver _vehicle;
					[_x] orderGetIn true;
				};
				if (isNull (assignedVehicle _x) && isNull (assignedCommander _vehicle)) then {
					_x assignAsCommander _vehicle;
					[_x] orderGetIn true;
				};
				if (isNull (assignedVehicle _x) && isNull (assignedGunner _vehicle)) then {
					_x assignAsGunner _vehicle;
					[_x] orderGetIn true;
				};
				if (isNull (assignedVehicle _x)) then {
					_x assignAsCargo _vehicle;
					[_x] orderGetIn true;
				};
			} foreach units _self.Group;
		};
		
		private method SetState("_state" as AiSquadState, "_timeoutTime" as Scalar)
		{
			_mState = _state;
			_mCurrentActionTimeoutTime = time + _timeoutTime;
			
			if (_state == AiSquadState.Idle) then {
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
			};
		};
		
		private method SetIdleIfActionTimedOut()
		{
			if (_mState != AiSquadState.Idle && time > _mCurrentActionTimeoutTime) then {
				[AiSquadState.Idle, 0] call _self.SetState;
				player sideChat "Timeout. Idle...";
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
			};
		};
		
		private method Boolean WholeGroupInVehicle()
		{
			scopeName "main";
		
			{
				if (vehicle _x == _x) then {
					false breakOut "main";
				};
			} foreach units _self.Group;
			
			true
		};
		
		private method MakeNewDecision()
		{
			private ["_nearestIntrusionVehicle" as IntrusionVehicle, "_waypoint" as Array];
			
			scopeName "main";

			_mUnit = [_mCurrentOrder.TargetPosition] call _self.GetClosestTeamMember;
			
			if (!isNull _mUnit) then
			{
				private ["_targets" as Array, "_seeEnemies" as Boolean, "_targetSide" as Side];
				_seeEnemies = false;
				
				// If infantry have see enemy targets, get out of vehicle
				if (call _self.WholeGroupInVehicle && !_mVehicleIsSquadVehicle) then {
					_targets = (leader _self.Group) nearTargets 500;
					{
						_targetSide = _x select 2;
						if (!([side _self.Group, _targetSide] call BIS_fnc_sideIsEnemy)) then {
							_seeEnemies = true;
						};
					} foreach _targets;
					
					if (_seeEnemies) then {
						[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
						[AiSquadState.ExitingVehicle, 20] call _self.SetState;
						player sideChat "Exiting vehicle #3";
						breakOut "main";
					};
				};
				
				// if within 30 meters of enemy flag, have a unit to get it.
				if (!isNull _mResourceLocation && { _mResourceLocation.Side != side _self.Group && vehicle _mUnit distance _mResourceLocation.Flag < 30 }) then
				{
					if (_mVehicleIsSquadVehicle && !isNull driver _mVehicle) then {
						_mUnit = driver _mVehicle;
						unassignVehicle _mUnit;
						[_mUnit] orderGetIn false;
					}
					else {
						if (vehicle _mUnit != _mUnit) then {
							[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
							[AiSquadState.ExitingVehicle, 20] call _self.SetState;
							player sideChat "Exiting vehicle #1";
						};
					};
					
					_mUnit doMove getPos _mResourceLocation.Flag;
					_mUnit setBehaviour "CARELESS";
					[AiSquadState.SingleUnitGettingFlag, 30] call _self.SetState;
					player sideChat "SingleUnitGettingFlag";
					breakOut "main";
				};
				
				// If squad is unmounted and have their intrusion vehicle, board it
				if (!(call _self.WholeGroupInVehicle) && _mVehicleIsSquadVehicle && alive _mVehicle) then {
					[_mVehicle] call _self.EnterVehicle;
					[AiSquadState.BoardingVehicle, 30] call _self.SetState;
					player sideChat "Entering vehicle";
					breakOut "main";
				};
				
				// If within 100 meters from an order's target position, and in a vehicle, stop and get out
				if (!_mVehicleIsSquadVehicle) then {
					if (vehicle _mUnit distance _mCurrentOrder.TargetPosition < 100 && vehicle _mUnit != _mUnit) then
					{
						[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
						[AiSquadState.ExitingVehicle, 20] call _self.SetState;
						player sideChat "Exiting vehicle #2";
						breakOut "main";
					};
				};

				// If within 200 meters from enemy flag, or in a vehicle, then move towards the flag.
				if (vehicle _mUnit distance _mCurrentOrder.TargetPosition < 200 || vehicle _mUnit != _mUnit) then
				{
					_waypoint = _self.Group addWaypoint [_mCurrentOrder.TargetPosition, 10];
					_waypoint setWaypointSpeed "LIMITED";
					_self.Group setSpeedMode "LIMITED";
					[AiSquadState.Moving, 120] call _self.SetState;
					player sideChat "Moving";
					breakOut "main";
				};
				
				// If there is a vehicle nearby and no enemies, then board it.
				if (!_seeEnemies) then {
					_nearestIntrusionVehicle = [side _self.Group, getPos leader _self.Group] call _mVehicleSpawner.GetNearestEmptyFreeVehicle;
					
					if (!isNull _nearestIntrusionVehicle && { (leader _self.Group) distance _nearestIntrusionVehicle.Vehicle < 500 }) then {
						[_nearestIntrusionVehicle.Vehicle] call _self.EnterVehicle;
						[AiSquadState.BoardingVehicle, 60] call _self.SetState;
						player sideChat "BoardingVehicle";
						breakOut "main";
					};
				};
				
				// Else: Move to the closest of enemy flag and the car park.
			};
		};
		
		private method CheckIfFinishedSingleUnitGettingFlag()
		{
			if (_mUnit distance _mResourceLocation.Flag < 5) then {
				if (alive _mUnit && _mResourceLocation.Side != side _self.Group) then {
					[_mResourceLocation.MarkerName, side _self.Group] call ResourceLocationHandler.SetNewFlagOwner;
					_mCurrentOrder = classNull;
				};
				
				[AiSquadState.Idle, 0] call _self.SetState;
				player sideChat "Idle";
			};
		};
		
		private method CheckIfFinishedMoving()
		{
			private ["_targetDistance" as Scalar];
			
			_targetDistance = 3;
			if (call _self.WholeGroupInVehicle) then {
				_targetDistance = 100;
			};
			if (_mVehicleIsSquadVehicle) then {
				_targetDistance = 15;
			};
		
			if (vehicle _mUnit distance _mCurrentOrder.TargetPosition < _targetDistance) then {
				[AiSquadState.Idle, 0] call _self.SetState;
				player sideChat "Finished moving. Idle...";
			};
		};
		
		private method CheckIfFinishedBoardingVehicle()
		{
			if ({ vehicle _x == _mVehicle } count units _self.Group == count units _self.Group) then {
				[AiSquadState.Idle, 0] call _self.SetState;
			};
		};
		
		private method CheckIfFinishedExitingVehicle()
		{
			//_mVehicle forceSpeed 0;
			if (speed _mVehicle < 0.1) then {
				//_mVehicle forceSpeed -1;
				call _self.ExitVehicle;
				[AiSquadState.Idle, 0] call _self.SetState;
				//_mVehicle forceSpeed -1;
			};
		};
		
		private method RespawnIfDead()
		{
			private ["_alive" as Boolean, "_noOfUnits" as Scalar];
			
			_alive = true;
			if ({canMove _x} count units _self.Group == 0) then {
				_alive = false;
			};
			
			if (!_alive) then {
				_noOfUnits = count units _self.Group;
				
				{
					_x setDamage 1
				} foreach units _self.Group;
				
				(units _self.Group) joinSilent grpNull;
				
				for "_i" from 1 to _noOfUnits do {
					_mUnitInfo.UnitClassName createUnit [getMarkerPos _mMapMarkerInfo.BaseMarkerName, _self.Group];
				};
				
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
				_mState = AiSquadState.Idle;
			};
		};
		
		private method BeamToBaseIfSquadVehicleIsThere()
		{
			private ["_vehicles" as Array, "_vehicle" as IntrusionVehicle, "_driverSeats" as Array, "_commanderSeats" as Array, "_gunnerSeats" as Array ];
			private ["_driverIn" as Boolean, "_commanderIn" as Boolean, "_gunnerIn" as Boolean, "_unit" as Object, "_basePos" as Array];
			
			_vehicles = [_self.Group] call _mVehicleSpawner.GetIntrusionVehiclesByGroup;
			
			if (count _vehicles > 0) then {
				_vehicle = _vehicles select 0;
				
				_basePos = getMarkerPos _mMapMarkerInfo.BaseMarkerName;
				_unit = [_basePos] call _self.GetClosestTeamMember;

				if (((vehicle _unit) distance _basePos) > 200 && (_vehicle.Vehicle distance _basePos) < 150) then {
					_driverIn = false;
					_commanderIn = false;
					_gunnerIn = false;
					
					_driverSeats = fullCrew [_vehicle.Vehicle, "driver", true];
					_commanderSeats = fullCrew [_vehicle.Vehicle, "commander", true];
					_gunnerSeats = fullCrew [_vehicle.Vehicle, "gunner", true];

					{
						_x setPos _basePos;
						
						if (!_driverIn && count _driverSeats > 0) then {
							_x assignAsDriver _vehicle.Vehicle;
							[_x] orderGetIn true;
							_driverIn = true;
						}
						else {
							if (!_commanderIn && count _commanderSeats > 0) then {
								_x assignAsCommander _vehicle.Vehicle;
								[_x] orderGetIn true;
								_commanderIn = true;
							}
							else {
								if (!_gunnerIn && count _gunnerSeats > 0) then {
									_x assignAsGunner _vehicle.Vehicle;
									[_x] orderGetIn true;
									_gunnerIn = true;
								}
								else {
									_x assignAsCargo _vehicle.Vehicle;
									[_x] orderGetIn true;
								};
							};
						};
					} foreach units _self.Group;
					
					_mVehicle = _vehicle.Vehicle;
					_mVehicleIsSquadVehicle = true;
					[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
					[AiSquadState.BoardingVehicle, 90] call _self.SetState;
					call _self.CreateOrderOnOwnInitiative;
					player sideChat "Beaming. Idle...";
				};
			};
		};
		
		private method UpdateOrder()
		{
			if (isNull _mCurrentOrder) then {
				call _self.CreateOrderOnOwnInitiative;
				player sideChat "new order #1.";
			}
			else {
				// If flag at order target location is friendly, set a new order
				if (_mResourceLocation.Side == side _self.Group) then {
					call _self.CreateOrderOnOwnInitiative;
					player sideChat "new order #2.";
				}
			};
		};
		
		// Gives the AI squad an opportunity to act.
		public method Act()
		{
			call _self.RespawnIfDead;
			call _self.SetIdleIfActionTimedOut;
			call _self.BeamToBaseIfSquadVehicleIsThere;
			call _self.UpdateOrder;
			
			if (_mState == AiSquadState.Idle && !isNull _mVehicle && { !alive _mVehicle }) then {
				call _self.ExitVehicle;
				_mVehicle = objNull;
				_mVehicleIsSquadVehicle = false;
			};
			
			switch (_mState) do {
				case AiSquadState.Idle: { call _self.MakeNewDecision; };
				case AiSquadState.SingleUnitGettingFlag: { call _self.CheckIfFinishedSingleUnitGettingFlag; };
				case AiSquadState.Moving: { call _self.CheckIfFinishedMoving; };
				case AiSquadState.BoardingVehicle: { call _self.CheckIfFinishedBoardingVehicle; };
				case AiSquadState.ExitingVehicle: { call _self.CheckIfFinishedExitingVehicle; };
			};
		};
	};
};
