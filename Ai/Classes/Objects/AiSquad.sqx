/*
 * Name:	AiSquad
 * Date:	2019-02-19
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Models an AI squad.
 */

using Intrusion.Common;
using Intrusion.Server;
using Sqx.Collections;
using Sqx.Waypoints;

namespace Intrusion.Ai
{
	public class AiSquad
	{
		private fields ["_mMapMarkerInfo" as MapMarkerInfo, "_mVehicle" as Object, "_mCurrentOrder" as Order, "_mVehicleSpawner" as IVehicleSpawner];
		private fields ["_mState" as AiSquadState, "_mStateSetTime" as Scalar, "_mCurrentActionTimeoutTime" as Scalar, "_mLeaderPos" as Array, "_mUnit" as Object, "_mResourceLocation" as ResourceLocation];
	
		// Creates an AiSquad object.
		// _noOfUnits (Scalar): Number of units to spawn.
		public constructor("_unitsConfig" as IAiUnitsConfig, "_mapMarkersConfig" as IMapMarkersConfig, "_vehicleSpawner" as IVehicleSpawner, "_side" as Side, "_noOfUnits" as Scalar)
		{
			private ["_unitInfo" as AiUnitInfo];
			
			_mMapMarkerInfo = [_side] call _mapMarkersConfig.GetMapMarkerInfo;
			_mVehicleSpawner = _vehicleSpawner;
			_unitInfo = [_side] call _unitsConfig.GetUnitInfo;
			_self.Group = createGroup [_side, true];
			_mHasActed = false;
			_mState = AiSquadState.Idle;
			_mVehicle = objNull;
			_mCurrentActionTimeoutTime = time;
			_mCurrentOrder = classNull;
			_mUnit = objNull;
			_mResourceLocation = classNull;
			
			for "_i" from 1 to _noOfUnits do {
				_unitInfo.UnitClassName createUnit [getMarkerPos _mMapMarkerInfo.BaseMarkerName, _self.Group];
			};
		};
		
		// Gets the AI squad's group.
		public property Group Group { get; private set; };
		
		// Updates the tracking information of the squad.
		private method UpdateTracking()
		{
			_mLeaderPos = getPos vehicle leader _self.Group;
		};
		
		// Gets the team member closest to a position.
		// Returns (Object): The closest team member. objNull if no unit that can stand was found or if the group is empty.
		private method Object GetClosestTeamMember("_pos" as Array)
		{
			private ["_closestUnit" as Object, "_closestDistance" as Scalar];
			
			_closestDistance = 99999999;
			_closestUnit = objNull;
			
			{
				if (canStand _x && _x distance _pos < _closestDistance) then {
					_closestUnit = _x;
					_closestDistance = _x distance _pos;
				};
			} foreach units _self.Group;
		};
		
		private method CreateOrderOnOwnInitiative()
		{
			private ["_resourceLocationCollection" as ResourceLocationCollection, "_location" as ResourceLocation, "_locations" as Array /* of ResourceLocation */, "_valuedLocations" as Array /* of ValuedObject */];
			private ["_count" as Scalar, "_index"];
			
			waitUntil { PublicVariableHandler.ResourceLocationCollectionHasValue };
			
			_resourceLocationCollection = call PublicVariableHandler.GetResourceLocationCollection;
			_locations = call _resourceLocationCollection.GetResourceLocations;
			_count = 0;
			
			// Find the three enemny (or neutral) resource locations closest to the base and select a random one of them.
			_valuedLocations = [];
			{
				_location = _x;
				
				if (_location.Side != side _self.Group) then {
					_valuedLocations pushBack [_location, getMarkerPos _location.MarkerName distance getMarkerPos _mMapMarkerInfo.BaseMarkerName] new ValuedObject;
					_count = _count + 1;
				};
			} foreach _locations as ResourceLocation;
			
			_valuedLocations = [_valuedLocations] call Sorter.QSort;
			
			if (_count > 3) then {
				_count = 3;
			};
			
			if (_count > 0) then {
				_index = floor random _count;
				_location = ((_valuedLocations select 0) as ValuedObject).Object as ResourceLocation;
				
				_mResourceLocation = _location;
				_mCurrentOrder = [_self.Group, OrderType.Attack, getMarkerPos _location.MarkerName] new Order;
			};
			
			// If there is no flags to capture, maybe one can chose to defend one instead.
		};
		
		private method ExitVehicle()
		{
			{
				if (!isNull assignedVehicle _x) then {
					unassignVehicle _x;
					moveOut _x;
				};
			} foreach units _self.Group;
		};
		
		private method EnterVehicle("_vehicle" as Object)
		{
			_mVehicle = _vehicle;
			
			{
				if (isNull assignedDriver _vehicle) then {
					_x assignAsDriver _vehicle;
					_x orderGetIn true;
				}
				else {
					_x assignAsCargo _vehicle;
					_x orderGetIn true;
				};
			} foreach units _self.Group;
		};
		
		private method SetState("_state" as AiSquadState, "_timeoutTime" as Scalar)
		{
			_mState = _state;
			_mStateSetTime = time;
			_mCurrentActionTimeoutTime = time + _timeoutTime;
			
			if (_state == AiSquadState.Idle) then {
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
			};
		};
		
		private method SetIdleIfActionTimedOut()
		{
			if (time > _mCurrentActionTimeoutTime) then {
				[AiSquadState.Idle, 0] call _self.SetState;	
				[_self.Group] call WaypointHelper.DeleteAllWaypointsFromGroup;
			};
		};
		
		private method MakeNewDecision()
		{
			private ["_unit" as Object, "_nearestIntrusionVehicle" as IntrusionVehicle];
			
			scopeName "main";

/*
			// If with 1 meter of enemy flag, take it.
			_unit = [_mCurrentOrder.TargetPosition] call _self.GetClosestTeamMember;
			if (!isNull _unit && {vehicle _unit distance _mCurrentOrder.TargetPosition < 2}) then {
				// Take flag
				
				breakOut "main";
			};
*/

			_unit = [_mCurrentOrder.TargetPosition] call _self.GetClosestTeamMember;
			_mUnit = _unit;
			
			if (!isNull _unit) then
			{
				// if within 25 meters of enemy flag, have a unit to get it.
				if (vehicle _unit distance _mCurrentOrder.TargetPosition < 25) then
				{
					if (vehicle _unit != _unit) then {
						call _self.ExitVehicle;
					};
					
					_unit moveTo _mCurrentOrder.TargetPosition;
					[AiSquadState.SingleUnitGettingFlag, 30] call _self.SetState;
					breakOut "main";
				};

				// If within 200 meters from enemy flag, or in a vehicle, then move towards the flag.
				if (vehicle _unit distance _mCurrentOrder.TargetPosition < 200) then
				{
					_self.Group addWaypoint [getMarkerPos _mCurrentOrder.TargetPosition, 10];
					[AiSquadState.Moving, 120] call _self.SetState;
					breakOut "main";
				};
				
				
				// If there is a vehicle nearby, then board it.
				_nearestIntrusionVehicle = [side _self.Group, getPos leader _self.Group] call _mVehicleSpawner.GetNearestEmptyFreeVehicle;
				
				if (!isNull _nearestIntrusionVehicle && { (leader _self.Group) distance _nearestIntrusionVehicle.Vehicle < 500 }) then {
					[_nearestIntrusionVehicle.Vehicle] call _self.EnterVehicle;
					[AiSquadState.BoardingVehicle, 60] call _self.SetState;
				};
				
				// Else: Move to the closest of enemy flag and the car park.
				
				if (!_mHasActed) then {
					_self.Group addWaypoint [getMarkerPos _mMapMarkerInfo.CarParkMarkerName, 0];
				};
			};
		};
		
		private method CheckIfFinishedSingleUnitGettingFlag()
		{
			if (_mUnit distance _mResourceLocation.Flag < 1) then {
				if (alive _mUnit && _mResourceLocation.Side != side _self.Group) then {
					[_mResourceLocation.MarkerName, side _self.Group] call ResourceLocationHandler.SetNewFlagOwner;
				};
				
				[AiSquadState.Idle, 0] call _self.SetState;
			};
		};
		
		private method CheckIfFinishedMoving()
		{
			if (vehicle _mUnit distance _mResourceLocation.Flag < 20) then {
				[AiSquadState.Idle, 0] call _self.SetState;
			};
		};
		
		private method CheckIfFinishedBoardingVehicle()
		{
			if ({ vehicle _x == _mVehicle } count units _self.Group == count units _self.Group) then {
				[AiSquadState.Idle, 0] call _self.SetState;
			};
		};
		
		// Gives the AI squad an opportunity to act.
		public method Act()
		{
			call _self.UpdateTracking;
			call _self.SetIdleIfActionTimedOut;
			
			if (isNull _mCurrentOrder) then {
				call _self.CreateOrderOnOwnInitiative;
			};
			
			switch (_mState) do {
				case AiSquadState.Idle: { call _self.MakeNewDecision; };
				case AiSquadState.SingleUnitGettingFlag: { call _self.CheckIfFinishedSingleUnitGettingFlag; };
				case AiSquadState.Moving: { call _self.CheckIfFinishedMoving; };
				case AiSquadState.BoardingVehicle: { call _self.CheckIfFinishedBoardingVehicle; };
			};
		};
	};
};
