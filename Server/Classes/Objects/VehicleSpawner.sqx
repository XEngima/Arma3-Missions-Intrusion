/*
 * Name:    VehicleSpawner
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Handles all mission vehicle spawns.
 */
using Intrusion.Common;
using Intrusion.Communication;
 
namespace Intrusion.Server
{
	public class VehicleSpawner : IVehicleSpawner
	{
		private fields ["_mSide" as Side, "_mAllIntrusionVehicles" as Array /* of IntrusionVehicle */];
	
		// Creates a VehicleHandler object.
		public constructor {
			params ["_side" as Side];
			
			_mSide = _side;
			_mAllIntrusionVehicles = [];
		};
		
		// Finds a free spawn position around a given position.
		// _markPos (Array): The position where to find a free spawn position.
		// _initialRadius (Scalar): Optional. The initial radius how far from the position that is ok. This
		// value will expand until a position is found.
		private static method FindSpawnPos {
			params ["_markPos" as Array, ["_initialRadius" as Scalar, 0]];
			private ["_spawnpos", "_randir", "_extendedRadius", "_randis", "_houses", "_vehicles", "_isFlat", "_danger", "_foundIt", "_tries"];
			[str _this + " VehicleHandler.FindSpawnPos"] call LogHandler.Debug;
			
			_spawnpos = [];
			_foundIt = false;
			_tries = 0;
			_extendedRadius = 0;
			
			while { true } do {
				scopeName "SpawnPosGen";
				
				_randir = floor random 360;
				_randis = _initialRadius + floor random _extendedRadius;
				_spawnpos = [(_markpos select 0) + ((sin _randir) * _randis), (_markpos select 1) + ((cos _randir) * _randis), 0.1];
				_houses = nearestObjects [_spawnpos, ["house","wall"], 50];
				_vehicles = nearestObjects [_spawnpos, ["LandVehicle", "Land_BagBunker_01_Large_green_F", "Land_TTowerBig_2_F"], 20];
				_isFlat = _spawnpos isFlatEmpty [2, -1, 0.5, 10, 0, false, objNull ]; 
				_danger = false;
				{ if (floor(_spawnpos distance getPos _x) < 10) then { _danger=true; }; } forEach _houses;
				{ if (floor(_spawnpos distance getPos _x) < 8) then { _danger=true; }; } forEach _vehicles;
				if (surfaceIsWater _spawnpos) then { _danger=true; };
				if (count _isFlat < 1 ) then { _danger=true; };
				if (!_danger) then { 
					_foundIt = true;
					breakOut "SpawnPosGen"
				};
				_tries = _tries + 1;
				_extendedRadius = _extendedRadius + 1;
				sleep 0.1;
			};
			
			if (!_foundIt) then {
				_spawnPos = [];
			};
			
			_spawnpos		
		};

		// Spawns a vehicle on a side's car park.
		// _vehicleClass (String): Vehicle class to spawn.
		// _side (Side): The side's carpark on which to spawn the vehicle.
		// Returns (Object): The spawned Intrusioni vehicle.
		public method IntrusionVehicle SpawnVehicleOnCarpark {
		    params ["_vehicleClass" as String, ["_professionType" as ProfessionType, ProfessionType.Undefined], ["_group" as Group, grpNull], ["_cost" as Scalar, 0]];
		    private ["_vehicleObj" as Object, "_spawnDir" as Scalar, "_spawnPos" as Array];
		    private ["_markerConfig" as SideMarkerInfo, "_intrusionVehicle" as IntrusionVehicle];
		    [str _this + " VehicleHandler.SpawnVehicleOnCarpark"] call LogHandler.Debug;
		    
		    _markerConfig = [_mSide] call SideMarkersConfig.GetSideMarkerInfo;
		    
			_spawnDir = markerDir _markerConfig.CarParkMarkerName;
		    _spawnPos = [getMarkerPos _markerConfig.CarParkMarkerName, 10] call _self.FindSpawnPos;
		    
		    while {count _spawnPos == 0} do {
		    	_spawnPos = [getMarkerPos _markerConfig.CarParkMarkerName, 10] call _self.FindSpawnPos;
		    };
		    
		    _vehicleObj = _vehicleClass createVehicle [_spawnPos select 0, _spawnPos select 1, 100];
		    _vehicleObj setDir _spawnDir;
		    _vehicleObj setPos [_spawnPos select 0, _spawnPos select 1, 0.1];
		    
        	_intrusionVehicle = [_vehicleObj, _mSide, _professionType, _group, _cost] new IntrusionVehicle;
        	_vehicleObj setVariable ["IntrusionVehicle", _intrusionVehicle, true];
        	_mAllIntrusionVehicles pushBack _intrusionVehicle;
        	
			["ClientVehicleHandler.GroupLockVehicles", [[_vehicleObj]]] call Remote.Invoke;
        	
		    _intrusionVehicle
		};
		
		// Spawns a free vehicle on a side's car park.
		// _side (Side): The side's carpark on which to spawn the vehicle.
		// Returns (Object): The spawned Intrusion vehicle.
		public method IntrusionVehicle SpawnFreeVehicleOnCarpark {
		    private ["_vehicleClass" as String, "_intrusionVehicle" as IntrusionVehicle];
			
        	["Spawning free vehicle at side " + str _mSide] call LogHandler.Info;
        	
        	_vehicleClass = selectRandom ([_mSide, ProfessionType.Undefined] call VehicleClassNamesConfig.GetProVehiclesClassNames);
        	_intrusionVehicle = [_vehicleClass] call _self.SpawnVehicleOnCarpark;
        	
        	_intrusionVehicle
		};
		
		// Counts a side's free vehicles at the base.
		// _side (Side): The side to count vehicles for.
		// Returns (Scalar): The number of free vehicles at the side's base.
		public method Scalar CountFreeVehiclesAtBase {
			private ["_vehiclesAtBaseCount" as Scalar, "_markerInfo" as SideMarkerInfo];
			
    		_markerInfo = [_mSide] call SideMarkersConfig.GetSideMarkerInfo;
    		_vehiclesAtBaseCount = 0;

			{
	        	private ["_iVehicle" as IntrusionVehicle];
	        	_iVehicle = _x;
	        	
	            if (alive _iVehicle.Vehicle && (((_iVehicle.Vehicle) distance getMarkerPos (_markerInfo.CarParkMarkerName)) < 100) && _iVehicle.OwnerProfession == ProfessionType.Undefined)  then { // TODO: Should not need parenthesis around _iVehicle.Vehicle and _markerConfig.CarParkMarkerName...
	                _vehiclesAtBaseCount = _vehiclesAtBaseCount + 1;
	            };
	        } foreach _mAllIntrusionVehicles as IntrusionVehicle;
	        
	        _vehiclesAtBaseCount
		};
	};
};
